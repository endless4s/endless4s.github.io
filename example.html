<!DOCTYPE html>
<html lang="en" class="no-js">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta http-equiv="x-ua-compatible" content="ie=edge">
<meta name="description" content="Scala library to describe event sourced entities using tagless-final algebras, running with built-in implementations for Akka.">
<meta property="og:title" content="Endless4s">
<meta property="og:description" content="Scala library to describe event sourced entities using tagless-final algebras, running with built-in implementations for Akka.">
<meta property="og:image" content="https://endless4s.github.io/logo-open-graph.png">
<meta name="generator" content="Paradox, paradox-material-theme=0.6.0, mkdocs-material=3.0.3">

<meta name="lang:clipboard.copy" content="Copy to clipboard">
<meta name="lang:clipboard.copied" content="Copied to clipboard">
<meta name="lang:search.language" content="">
<meta name="lang:search.pipeline.stopwords" content="true">
<meta name="lang:search.pipeline.trimmer" content="true">
<meta name="lang:search.result.none" content="No matching documents">
<meta name="lang:search.result.one" content="1 matching document">
<meta name="lang:search.result.other" content="# matching documents">
<meta name="lang:search.tokenizer" content="[\s\-]+">


<meta name="description" content="Scala library to describe event sourced entities using tagless-final algebras, running with built-in implementations for Akka.">
<link rel="shortcut icon" href="favicon.png">
<title>Example app Â· </title>
<link rel="stylesheet" href="assets/stylesheets/application.451f80e5.css">
<link rel="stylesheet" href="assets/stylesheets/application-palette.22915126.css">
<meta name="theme-color" content="#546e7a" />
<link rel="stylesheet" href="lib/material__tabs/dist/mdc.tabs.min.css">
<link rel="stylesheet" href="lib/prettify/prettify.css">
<script src="assets/javascripts/modernizr.1aa3b519.js"></script>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Overpass:300,400,400i,700|Overpass+Mono">
<style>
body,input{font-family:"Overpass","Helvetica Neue",Helvetica,Arial,sans-serif}
code,kbd,pre{font-family:"Overpass Mono","Courier New",Courier,monospace}
</style>
<link rel="stylesheet" href="assets/fonts/font-awesome.css">
<link rel="stylesheet" href="assets/fonts/material-icons.css">
<link rel="stylesheet" href="assets/stylesheets/paradox-material-theme.css">
</head>
<body
data-md-color-primary="blue-grey"
data-md-color-accent="red"
>
<input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
<input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
<label class="md-overlay" data-md-component="overlay" for="__drawer"></label>
<header class="md-header" data-md-component="header">
<nav class="md-header-nav md-grid">
<div class="md-flex">
<div class="md-flex__cell md-flex__cell--shrink">
<a href="index.html" title="" class="md-header-nav__button md-logo">
<img src="logo-symbol-only.svg" width="24" height="24">
</a>
</div>
<div class="md-flex__cell md-flex__cell--shrink">
<label class="md-icon md-icon--menu md-header-nav__button" for="__drawer"></label>
</div>
<div class="md-flex__cell md-flex__cell--stretch">
<div class="md-flex__ellipsis md-header-nav__title" data-md-component="title">
<span class="md-header-nav__topic">
</span>
<span class="md-header-nav__topic">
Example app
</span>
</div>
</div>
<div class="md-flex__cell md-flex__cell--shrink">
<label class="md-icon md-icon--search md-header-nav__button" for="__search"></label>
<div class="md-search" data-md-component="search" role="dialog">
<label class="md-search__overlay" for="__search"></label>
<div class="md-search__inner" role="search">
<form class="md-search__form" name="search">
<input type="text" class="md-search__input" name="query" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="query" data-md-state="active">
<label class="md-icon md-search__icon" for="__search"></label>
<button type="reset" class="md-icon md-search__icon" data-md-component="reset" tabindex="-1">&#xE5CD;</button>
</form>
<div class="md-search__output">
<div class="md-search__scrollwrap" data-md-scrollfix>
<div class="md-search-result" data-md-component="result">
<div class="md-search-result__meta">
Type to start searching
</div>
<ol class="md-search-result__list"></ol>
</div>
</div>
</div>
</div>
</div>

</div>
<div class="md-flex__cell md-flex__cell--shrink">
<div class="md-header-nav__source">
<a href="https://github.com/endless4s/endless"
title="Go to repository"
class="md-source"
data-md-source="github">
<div class="md-source__icon">
<i class="fa fa-github"></i>
</div>
<div class="md-source__repository">
endless4s/endless
</div>
</a>

</div>
</div>
</div>
</nav>
</header>

<div class="md-container">
<main class="md-main">
<div class="md-main__inner md-grid" data-md-component="container">
<div class="md-sidebar md-sidebar--primary" data-md-component="navigation">
<div class="md-sidebar__scrollwrap">
<div class="md-sidebar__inner">
<nav class="md-nav md-nav--primary" data-md-level="0" style="visibility: hidden">
<label class="md-nav__title md-nav__title--site" for="drawer">
<a href="index.html" title="" class="md-nav__button md-logo">
<span class="md-nav__button md-logo">
<img src="logo-symbol-only.svg" width="24" height="24">
</a>
<a href="index.html" title="">
</a>
</label>
<div class="md-nav__source">
<a href="https://github.com/endless4s/endless"
title="Go to repository"
class="md-source"
data-md-source="github">
<div class="md-source__icon">
<i class="fa fa-github"></i>
</div>
<div class="md-source__repository">
endless4s/endless
</div>
</a>

</div>
<ul>
  <li><a href="getting-started.html" class="page">Getting Started</a></li>
  <li><a href="nutshell.html" class="page">In a nutshell</a></li>
  <li><a href="abstractions.html" class="page">Abstractions</a>
  <ul>
    <li><a href="sharding.html" class="page">Sharding</a></li>
    <li><a href="entity.html" class="page">Entity</a></li>
    <li><a href="durable-entity.html" class="page">Durable entity</a></li>
    <li><a href="applier.html" class="page">EventApplier</a></li>
    <li><a href="protocol.html" class="page">CommandProtocol</a></li>
    <li><a href="sender.html" class="page">CommandSender</a></li>
    <li><a href="side-effect.html" class="page">Side-effect</a></li>
    <li><a href="effector.html" class="page">Effector</a></li>
    <li><a href="name.html" class="page">EntityNameProvider</a></li>
    <li><a href="id.html" class="page">EntityIDCodec</a></li>
    <li><a href="deployer.html" class="page">Deployer</a></li>
  </ul></li>
  <li><a href="runtime.html" class="page">Pekko and Akka runtimes</a></li>
  <li><a href="example.html" class="active page">Example app</a></li>
  <li><a href="reference.html" class="page">Reference</a></li>
  <li><a href="inspiration.html" class="page">Inspiration</a></li>
  <li><a href="discord.html" class="page">Questions &amp; answers</a></li>
</ul>
<nav class="md-nav md-nav--secondary">
<label class="md-nav__title" for="__toc">Table of contents</label>
<ul>
  <li><a href="example.html#example-app" class="header">Example app</a>
  <ul>
    <li><a href="example.html#api" class="header">API</a></li>
    <li><a href="example.html#scaffolding" class="header">Scaffolding</a></li>
    <li><a href="example.html#algebras" class="header">Algebras</a></li>
    <li><a href="example.html#implementations" class="header">Implementations</a></li>
    <li><a href="example.html#event-handling" class="header">Event handling</a></li>
    <li><a href="example.html#protocol" class="header">Protocol</a></li>
    <li><a href="example.html#side-effects" class="header">Side-effects</a></li>
    <li><a href="example.html#testing" class="header">Testing</a></li>
  </ul></li>
</ul>
</nav>

</nav>
<ul style="display: none">
<li class="md-nav__item md-version" id="project.version">
<label class="md-nav__link" for="__version">
<i class="md-icon" title="Version">label_outline</i> 0.29.0
</label>
</li>
</ul>
</div>
</div>
</div>
<div class="md-sidebar md-sidebar--secondary" data-md-component="toc">
<div class="md-sidebar__scrollwrap">
<div class="md-sidebar__inner">
<nav class="md-nav md-nav--secondary">
<label class="md-nav__title" for="__toc">Table of contents</label>
<ul>
  <li><a href="example.html#example-app" class="header">Example app</a>
  <ul>
    <li><a href="example.html#api" class="header">API</a></li>
    <li><a href="example.html#scaffolding" class="header">Scaffolding</a></li>
    <li><a href="example.html#algebras" class="header">Algebras</a></li>
    <li><a href="example.html#implementations" class="header">Implementations</a></li>
    <li><a href="example.html#event-handling" class="header">Event handling</a></li>
    <li><a href="example.html#protocol" class="header">Protocol</a></li>
    <li><a href="example.html#side-effects" class="header">Side-effects</a></li>
    <li><a href="example.html#testing" class="header">Testing</a></li>
  </ul></li>
</ul>
</nav>

</div>
</div>
</div>
<div class="md-content">
<article class="md-content__inner md-typeset">
<div class="md-content__searchable">
<h1><a href="#example-app" name="example-app" class="anchor"><span class="anchor-link"></span></a>Example app</h1>
<p>Endless example application is a small API for managing imaginary bookings for passenger trips from some origin to some destination, as well as tracking positions and speeds of vehicles. It can be found in <code>endless-example</code> and can be run directly: <code>sbt run</code>. </p>
<h2><a href="#api" name="api" class="anchor"><span class="anchor-link"></span></a>API</h2>
<p>It has a simple CRUD API for bookings and vehicles:</p>
<pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/endless4s/endless/tree/v0.29.0/example/src/main/scala/endless/example/app/HttpServer.scala#L40-L65" target="_blank" title="Go to snippet source">source</a><code class="language-scala">  HttpRoutes
    .of[IO] {
      case req @ POST -&gt; Root / &quot;booking&quot;        =&gt; postBooking(bookingRepository, req)
      case GET -&gt; Root / &quot;booking&quot; / UUIDVar(id) =&gt; getBooking(bookingRepository, id)
      case req @ PATCH -&gt; Root / &quot;booking&quot; / UUIDVar(id) =&gt;
        patchBooking(bookingRepository, req, id)
      case POST -&gt; Root / &quot;booking&quot; / UUIDVar(id) / &quot;cancel&quot; =&gt;
        cancelBooking(bookingRepository, id)
      case GET -&gt; Root / &quot;vehicle&quot; / UUIDVar(id) / &quot;speed&quot; =&gt;
        getVehicleSpeed(vehicleRepository, id)
      case GET -&gt; Root / &quot;vehicle&quot; / UUIDVar(id) / &quot;position&quot; =&gt;
        getVehiclePosition(vehicleRepository, id)
      case GET -&gt; Root / &quot;vehicle&quot; / UUIDVar(id) / &quot;recoveryCount&quot; =&gt;
        getVehicleRecoveryCount(vehicleRepository, id)
      case req @ POST -&gt; Root / &quot;vehicle&quot; / UUIDVar(id) / &quot;speed&quot; =&gt;
        setVehicleSpeed(vehicleRepository, id, req)
      case req @ POST -&gt; Root / &quot;vehicle&quot; / UUIDVar(id) / &quot;position&quot; =&gt;
        setVehiclePosition(vehicleRepository, id, req)
      case GET -&gt; Root / &quot;health&quot; =&gt;
        isUp.flatMap {
          case true  =&gt; Ok(&quot;OK&quot;)
          case false =&gt; ServiceUnavailable(&quot;Cluster member is down&quot;)
        }
    }
    .orNotFound
)</code></pre>
<h2><a href="#scaffolding" name="scaffolding" class="anchor"><span class="anchor-link"></span></a>Scaffolding</h2>
<p>The application is assembled via calls to <a href="api/core/endless/core/entity/Deployer$$deployRepository.html" title="endless.core.entity.Deployer.deployRepository"><code>deployRepository</code></a> (for bookings) and <a href="api/core/endless/core/entity/Deployer$$deployDurableRepository.html" title="endless.core.entity.Deployer.deployDurableRepository"><code>deployDurableEntity</code></a> (for vehicles) (see <a href="runtime.html">runtime</a> for more details)</p>
<p>Akka and Pekko runtimes essentially have the same API, so we&rsquo;ll use Pekko for the example:</p>
<pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/endless4s/endless/tree/v0.29.0/example/src/main/scala/endless/example/app/pekko/PekkoApp.scala#L69-L135" target="_blank" title="Go to snippet source">source</a><code class="language-scala">Resource
  .eval(Slf4jLogger.create[IO])
  .flatMap { implicit logger: Logger[IO] =&gt;
    PekkoCluster.managedResource[IO](actorSystem).flatMap {
      implicit cluster: PekkoCluster[IO] =&gt;
        implicit val eventSourcingDeploymentParameters
            : PekkoDeploymentParameters[IO, Booking, BookingEvent] =
          PekkoDeploymentParameters[IO, Booking, BookingEvent](
            customizeBehavior = (_, behavior) =&gt;
              behavior.eventAdapter(
                new EventAdapter[
                  BookingEvent,
                  endless.example.proto.booking.events.BookingEvent
                ] {
                  def toJournal(
                      e: BookingEvent
                  ): endless.example.proto.booking.events.BookingEvent =
                    eventAdapter.toJournal(e)

                  def manifest(event: BookingEvent): String = event.getClass.getName

                  def fromJournal(
                      p: endless.example.proto.booking.events.BookingEvent,
                      manifest: String
                  ): EventSeq[BookingEvent] = EventSeq.single(eventAdapter.fromJournal(p))
                }
              )
          )
        implicit val durableDeploymentParameters
            : PekkoDurableDeploymentParameters[IO, Vehicle] =
          PekkoDurableDeploymentParameters[IO, Vehicle](
            customizeBehavior = (_, behavior) =&gt;
              behavior.snapshotAdapter(new SnapshotAdapter[Option[Vehicle]] {
                def toJournal(state: Option[Vehicle]): Any = stateAdapter.toJournal(state)
                def fromJournal(from: Any): Option[Vehicle] = stateAdapter.fromJournal(from)
              })
          )
        Resource
          .both(
            deployRepository[
              IO,
              BookingID,
              Booking,
              BookingEvent,
              BookingAlg,
              BookingsAlg
            ](
              RepositoryInterpreter.lift(ShardedBookings(_)),
              BehaviorInterpreter.lift(BookingEntityBehavior(_)),
              SideEffectInterpreter.lift { case (_, _) =&gt; new BookingSideEffect() }
            ),
            deployDurableRepository[IO, VehicleID, Vehicle, VehicleAlg, VehiclesAlg](
              RepositoryInterpreter.lift(ShardedVehicles(_)),
              DurableBehaviorInterpreter.lift(VehicleEntityBehavior(_)),
              SideEffectInterpreter.lift { case (_, _) =&gt; new VehicleSideEffect() }
            )
          )
          .flatMap { case (bookingDeployment, vehicleDeployment) =&gt;
            HttpServer(
              port,
              bookingDeployment.repository,
              vehicleDeployment.repository,
              cluster.isMemberUp
            )
          }
    }
  }</code></pre>
<h2><a href="#algebras" name="algebras" class="anchor"><span class="anchor-link"></span></a>Algebras</h2>
<p>You might have spotted the two algebra types in the snippet above: </p>
<h3><a href="#repository" name="repository" class="anchor"><span class="anchor-link"></span></a>Repository</h3>
<pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/endless4s/endless/tree/v0.29.0/example/src/main/scala/endless/example/algebra/BookingsAlg.scala#L6-L8" target="_blank" title="Go to snippet source">source</a><code class="language-scala">trait BookingsAlg[F[_]] {
  def bookingFor(bookingID: BookingID): BookingAlg[F]
}</code></pre>
<p>Here&rsquo;s the sequence of operations happening behind the scenes when retrieving an instance of entity algebra: </p>
<img src="sequences/BookingRepository.png"/>
<h3><a href="#entity" name="entity" class="anchor"><span class="anchor-link"></span></a>Entity</h3>
<pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/endless4s/endless/tree/v0.29.0/example/src/main/scala/endless/example/algebra/BookingAlg.scala#L11-L28" target="_blank" title="Go to snippet source">source</a><code class="language-scala">trait BookingAlg[F[_]] {
  def place(
      bookingID: BookingID,
      time: Instant,
      passengerCount: Int,
      origin: LatLon,
      destination: LatLon
  ): F[BookingAlreadyExists \/ Unit]
  def get: F[BookingUnknown.type \/ Booking]
  def changeOrigin(newOrigin: LatLon): F[BookingUnknown.type \/ Unit]
  def changeDestination(newDestination: LatLon): F[BookingUnknown.type \/ Unit]
  def changeOriginAndDestination(
      newOrigin: LatLon,
      newDestination: LatLon
  ): F[BookingUnknown.type \/ Unit]
  def cancel: F[CancelError \/ Unit]
  def notifyCapacity(isAvailable: Boolean): F[BookingUnknown.type \/ Unit]
}</code></pre>
<h2><a href="#implementations" name="implementations" class="anchor"><span class="anchor-link"></span></a>Implementations</h2>
<p>Implementation of the repository algebra is trivial using <code>Sharding</code> instance (injected by <code>deployRepository</code>):</p>
<pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/endless4s/endless/tree/v0.29.0/example/src/main/scala/endless/example/logic/ShardedBookings.scala#L9-L12" target="_blank" title="Go to snippet source">source</a><code class="language-scala">final case class ShardedBookings[F[_]: Monad](sharding: Sharding[F, BookingID, BookingAlg])
    extends BookingsAlg[F] {
  def bookingFor(bookingID: BookingID): BookingAlg[F] = sharding.entityFor(bookingID)
}</code></pre>
<p>Implementation of behavior algebra is done using the <code>Entity</code> typeclass instance (also injected by <code>deployRepository</code>):</p>
<pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/endless4s/endless/tree/v0.29.0/example/src/main/scala/endless/example/logic/BookingEntityBehavior.scala#L21-L82" target="_blank" title="Go to snippet source">source</a><code class="language-scala">final case class BookingEntityBehavior[F[_]: Logger: Clock](
    entity: Entity[F, Booking, BookingEvent]
) extends BookingAlg[F] {
  import entity.*

  def place(
      bookingID: BookingID,
      time: Instant,
      passengerCount: Int,
      origin: LatLon,
      destination: LatLon
  ): F[BookingAlreadyExists \/ Unit] =
    ifUnknownF(
      Logger[F].info(show&quot;Creating booking with ID $bookingID&quot;) &gt;&gt; write(
        BookingPlaced(bookingID, time, origin, destination, passengerCount)
      )
    )(_ =&gt; BookingAlreadyExists(bookingID))

  def get: F[BookingUnknown.type \/ Booking] = ifKnown(identity)(BookingUnknown)

  def changeOrigin(newOrigin: LatLon): F[BookingUnknown.type \/ Unit] =
    ifKnownF(booking =&gt;
      if (booking.origin =!= newOrigin) entity.write(OriginChanged(newOrigin)) else ().pure
    )(BookingUnknown)

  def changeDestination(newDestination: LatLon): F[BookingUnknown.type \/ Unit] =
    ifKnownF(booking =&gt;
      if (booking.destination =!= newDestination) entity.write(DestinationChanged(newDestination))
      else ().pure
    )(BookingUnknown)

  def changeOriginAndDestination(
      newOrigin: LatLon,
      newDestination: LatLon
  ): F[BookingUnknown.type \/ Unit] = changeOrigin(newOrigin) &gt;&gt; changeDestination(newDestination)

  def cancel: F[CancelError \/ Unit] =
    ifKnownT[CancelError, Unit](booking =&gt;
      booking.status match {
        case Status.Accepted | Status.Pending =&gt;
          EitherT.liftF(
            (Clock[F].realTimeInstant &gt;&gt;= (timestamp =&gt;
              Logger[F]
                .info(show&quot;Cancelling booking with ID ${booking.id} at ${timestamp.toString}&quot;)
            )) &gt;&gt; entity.write(BookingCancelled)
          )
        case Status.Cancelled =&gt; EitherT.pure(())
        case Status.Rejected  =&gt; EitherT.leftT[F, Unit](BookingAlg.BookingWasRejected(booking.id))
      }
    )(
      BookingUnknown
    )

  def notifyCapacity(isAvailable: Boolean): F[BookingAlg.BookingUnknown.type \/ Unit] =
    ifKnownF(_.status match {
      case Status.Pending =&gt;
        if (isAvailable) entity.write(BookingAccepted) else entity.write(BookingRejected)
      case _ =&gt; ().pure
    })(
      BookingUnknown
    )
}</code></pre>
<h2><a href="#event-handling" name="event-handling" class="anchor"><span class="anchor-link"></span></a>Event handling</h2>
<p>In this simple example, events essentially set fields in the state:</p>
<pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/endless4s/endless/tree/v0.29.0/example/src/main/scala/endless/example/logic/BookingEventApplier.scala#L10-L38" target="_blank" title="Go to snippet source">source</a><code class="language-scala">class BookingEventApplier extends EventApplier[Booking, BookingEvent] {
  def apply(state: Option[Booking], event: BookingEvent): String \/ Option[Booking] =
    (event match {
      case BookingPlaced(bookingID, time, origin, destination, passengerCount) =&gt;
        state
          .toLeft(Booking(bookingID, time, origin, destination, passengerCount))
          .leftMap(_ =&gt; &quot;Booking already exists&quot;)
      case OriginChanged(newOrigin) =&gt;
        state
          .toRight(&quot;Attempt to change unknown booking&quot;)
          .map(_.copy(origin = newOrigin))
      case DestinationChanged(newDestination) =&gt;
        state
          .toRight(&quot;Attempt to change unknown booking&quot;)
          .map(_.copy(destination = newDestination))
      case BookingAccepted =&gt;
        state
          .toRight(&quot;Attempt to accept unknown booking&quot;)
          .map(_.copy(status = Booking.Status.Accepted))
      case BookingRejected =&gt;
        state
          .toRight(&quot;Attempt to reject unknown booking&quot;)
          .map(_.copy(status = Booking.Status.Rejected))
      case BookingCancelled =&gt;
        state
          .toRight(&quot;Attempt to cancel unknown booking&quot;)
          .map(_.copy(status = Booking.Status.Cancelled))
    }).map(Option(_))
}</code></pre>
<h2><a href="#protocol" name="protocol" class="anchor"><span class="anchor-link"></span></a>Protocol</h2>
<p>Command and reply encoding/decoding on client and server side is implemented with a subclass of <code>CommandProtocol</code>, in this case <code>ProtobufCommandProtocol</code> as we&rsquo;ll be using protobuf. On the client side, we translate invocations into instances of <code>OutgoingCommand</code> and make use of the <code>sendCommand</code> helper function:</p>
<pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/endless4s/endless/tree/v0.29.0/example/src/main/scala/endless/example/protocol/BookingCommandProtocol.scala#L26-L61" target="_blank" title="Go to snippet source">source</a><code class="language-scala">class BookingCommandProtocol extends ProtobufCommandProtocol[BookingID, BookingAlg] {
  override def clientFor[F[_]](
      id: BookingID
  )(implicit sender: CommandSender[F, BookingID]): BookingAlg[F] =
    new BookingAlg[F] {
      def place(
          bookingID: BookingID,
          time: Instant,
          passengerCount: Int,
          origin: LatLon,
          destination: LatLon
      ): F[BookingAlreadyExists \/ Unit] =
        sendCommand[F, BookingCommand, replies.PlaceBookingReply, BookingAlreadyExists \/ Unit](
          id,
          BookingCommand.of(
            Command.PlaceBookingV1(
              PlaceBookingV1(
                proto.BookingID(bookingID.show),
                Timestamp.of(time.getEpochSecond, time.getNano),
                passengerCount,
                proto.LatLonV1(origin.lat, origin.lon),
                proto.LatLonV1(destination.lat, destination.lon)
              )
            )
          ),
          {
            case replies
                  .PlaceBookingReply(replies.PlaceBookingReply.Reply.AlreadyExists(booking), _) =&gt;
              Left(BookingAlreadyExists(BookingID(UUID.fromString(booking.bookingId.value))))
            case replies.PlaceBookingReply(replies.PlaceBookingReply.Reply.Unit(_), _) =&gt; Right(())
            case replies.PlaceBookingReply(replies.PlaceBookingReply.Reply.Empty, _) =&gt;
              throw new UnexpectedReplyException
          }
        )

      // ...</code></pre>
<p>On the server side, we decode instances of <code>IncomingCommand</code> and make use of <code>handleCommand</code> to trigger relevant entity logic and encode the reply:</p>
<pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/endless4s/endless/tree/v0.29.0/example/src/main/scala/endless/example/protocol/BookingCommandProtocol.scala#L207-L233" target="_blank" title="Go to snippet source">source</a><code class="language-scala">override def server[F[_]]: Decoder[IncomingCommand[F, BookingAlg]] =
  ProtobufDecoder[BookingCommand].map(_.command match {
    case Command.Empty =&gt; throw new UnexpectedCommandException
    case Command.PlaceBookingV1(
          PlaceBookingV1(bookingID, time, passengerCount, origin, destination, _)
        ) =&gt;
      handleCommand[F, replies.PlaceBookingReply, BookingAlreadyExists \/ Unit](
        _.place(
          BookingID(UUID.fromString(bookingID.value)),
          Instant.ofEpochSecond(time.seconds, time.nanos),
          passengerCount,
          LatLon(origin.lat, origin.lon),
          LatLon(destination.lat, destination.lon)
        ),
        {
          case Left(bookingAlreadyExists) =&gt;
            replies.PlaceBookingReply(
              replies.PlaceBookingReply.Reply.AlreadyExists(
                replies.BookingAlreadyExistsV1(
                  proto.BookingID(bookingAlreadyExists.bookingID.show)
                )
              )
            )
          case Right(_) =&gt;
            replies.PlaceBookingReply(replies.PlaceBookingReply.Reply.Unit(UnitReply()))
        }
      )</code></pre>
<p>Here&rsquo;s an illustration of the chain of interactions taking place when placing a booking, both from the client and the server side:</p>
<img src="sequences/PlaceBookingClient.png"/>
<img src="sequences/PlaceBookingServer.png"/>
<h2><a href="#side-effects" name="side-effects" class="anchor"><span class="anchor-link"></span></a>Side-effects</h2>
<p>We describe the <em>availability</em> process as well as entity passivation using <code>Effector</code>: </p>
<pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/endless4s/endless/tree/v0.29.0/example/src/main/scala/endless/example/logic/BookingSideEffect.scala#L18-L49" target="_blank" title="Go to snippet source">source</a><code class="language-scala">class BookingSideEffect[F[_]: Logger: Monad]()(implicit
    availabilityAlg: AvailabilityAlg[F]
) extends SideEffect[F, Booking, BookingAlg] {
  def apply(trigger: Trigger, effector: Effector[F, Booking, BookingAlg]): F[Unit] = {
    import effector.*

    val availabilityProcess: Booking =&gt; F[Unit] = booking =&gt;
      (booking.status, trigger) match {
        case (Status.Pending, Trigger.AfterRecovery | Trigger.AfterPersistence) =&gt;
          (availabilityAlg.isCapacityAvailable(
            booking.time,
            booking.passengerCount
          ) &gt;&gt;= self.notifyCapacity).void
        case _ =&gt; ().pure
      }

    val handlePassivation: Booking =&gt; F[Unit] = {
      _.status match {
        case Status.Pending   =&gt; Applicative[F].unit
        case Status.Accepted  =&gt; enablePassivation(passivationDelay)
        case Status.Rejected  =&gt; enablePassivation()
        case Status.Cancelled =&gt; enablePassivation()
      }
    }

    ifKnown(booking =&gt; Logger[F].info(show&quot;State is now $booking&quot;)) &gt;&gt; ifKnown(
      availabilityProcess
    ) &gt;&gt; ifKnown(handlePassivation)
  }

  private val passivationDelay = 1.hour
}</code></pre>
<h2><a href="#testing" name="testing" class="anchor"><span class="anchor-link"></span></a>Testing</h2>
<p>Unit testing for entity algebra implementation, event handling and effector benefits from to the parametric nature of <code>F</code>: </p>
<pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/endless4s/endless/tree/v0.29.0/example/src/test/scala/endless/example/logic/BookingEntityBehaviorSuite.scala#L13-L66" target="_blank" title="Go to snippet source">source</a><code class="language-scala">class BookingEntityBehaviorSuite
    extends munit.CatsEffectSuite
    with munit.ScalaCheckEffectSuite
    with Generators {
  implicit private val logger: TestingLogger[IO] = TestingLogger.impl[IO]()
  private val bookingAlg = BookingEntityBehavior(EntityT.instance[IO, Booking, BookingEvent])
  private implicit val eventApplier: BookingEventApplier = new BookingEventApplier

  test(&quot;place booking&quot;) {
    forAllF { (booking: Booking) =&gt;
      bookingAlg
        .place(
          booking.id,
          booking.time,
          booking.passengerCount,
          booking.origin,
          booking.destination
        )
        .run(None)
        .map {
          case Right((events, _)) =&gt;
            assertEquals(
              events,
              Chain(
                BookingPlaced(
                  booking.id,
                  booking.time,
                  booking.origin,
                  booking.destination,
                  booking.passengerCount
                )
              )
            )
          case Left(error) =&gt; fail(error)
        }
        .flatMap(_ =&gt; assertIOBoolean(logger.logged.map(_.nonEmpty)))
    }
  }

  test(&quot;change origin and destination&quot;) {
    forAllF { (booking: Booking, newOrigin: LatLon, newDestination: LatLon) =&gt;
      bookingAlg
        .changeOriginAndDestination(newOrigin, newDestination)
        .run(Some(booking))
        .map {
          case Right((events, _)) =&gt;
            assertEquals(
              events,
              Chain[BookingEvent](OriginChanged(newOrigin), DestinationChanged(newDestination))
            )
          case _ =&gt; fail(&quot;unexpected&quot;)
        }
    }
  }</code></pre>
<pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/endless4s/endless/tree/v0.29.0/example/src/test/scala/endless/example/logic/BookingEventApplierSuite.scala#L8-L104" target="_blank" title="Go to snippet source">source</a><code class="language-scala">class BookingEventApplierSuite extends munit.ScalaCheckSuite with Generators {
  property(&quot;booking placed when unknown&quot;) {
    forAll { (booking: Booking) =&gt;
      val fold = new BookingEventApplier()(
        None,
        BookingPlaced(
          booking.id,
          booking.time,
          booking.origin,
          booking.destination,
          booking.passengerCount
        )
      )
      assertEquals(fold, Right(Some(booking)))
    }
  }

  property(&quot;booking placed when known&quot;) {
    forAll { (booking: Booking) =&gt;
      val fold = new BookingEventApplier()(
        Some(booking),
        BookingPlaced(
          booking.id,
          booking.time,
          booking.origin,
          booking.destination,
          booking.passengerCount
        )
      )
      assert(fold.isLeft)
    }
  }

  property(&quot;origin changed when known&quot;) {
    forAll { (booking: Booking, newOrigin: LatLon) =&gt;
      val fold = new BookingEventApplier()(Some(booking), OriginChanged(newOrigin))
      assertEquals(fold.toOption.flatMap(_.map(_.origin)), Option(newOrigin))
    }
  }

  property(&quot;origin changed when unknown&quot;) {
    forAll { (newOrigin: LatLon) =&gt;
      val fold = new BookingEventApplier()(None, OriginChanged(newOrigin))
      assert(fold.isLeft)
    }
  }

  property(&quot;destination changed when known&quot;) {
    forAll { (booking: Booking, newDestination: LatLon) =&gt;
      val fold = new BookingEventApplier()(Some(booking), DestinationChanged(newDestination))
      assertEquals(fold.toOption.flatMap(_.map(_.destination)), Option(newDestination))
    }
  }

  property(&quot;destination changed when unknown&quot;) {
    forAll { (newDestination: LatLon) =&gt;
      val fold = new BookingEventApplier()(None, DestinationChanged(newDestination))
      assert(fold.isLeft)
    }
  }

  property(&quot;booking accepted when known&quot;) {
    forAll { (booking: Booking) =&gt;
      val fold = new BookingEventApplier()(Some(booking), BookingAccepted)
      assertEquals(fold.toOption.flatMap(_.map(_.status)), Option(Booking.Status.Accepted))
    }
  }

  test(&quot;booking accepted when unknown&quot;) {
    val fold = new BookingEventApplier()(None, BookingAccepted)
    assert(fold.isLeft)
  }

  property(&quot;booking rejected when known&quot;) {
    forAll { (booking: Booking) =&gt;
      val fold = new BookingEventApplier()(Some(booking), BookingRejected)
      assertEquals(fold.toOption.flatMap(_.map(_.status)), Option(Booking.Status.Rejected))
    }
  }

  test(&quot;booking rejected when unknown&quot;) {
    val fold = new BookingEventApplier()(None, BookingRejected)
    assert(fold.isLeft)
  }

  property(&quot;booking cancelled when known&quot;) {
    forAll { (booking: Booking) =&gt;
      val fold = new BookingEventApplier()(Some(booking), BookingCancelled)
      assertEquals(fold.toOption.flatMap(_.map(_.status)), Option(Booking.Status.Cancelled))
    }
  }

  test(&quot;booking cancelled when unknown&quot;) {
    val fold = new BookingEventApplier()(None, BookingCancelled)
    assert(fold.isLeft)
  }
}</code></pre>
<pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/endless4s/endless/tree/v0.29.0/example/src/test/scala/endless/example/logic/BookingSideEffectSuite.scala#L19-L110" target="_blank" title="Go to snippet source">source</a><code class="language-scala">class BookingSideEffectSuite
    extends munit.CatsEffectSuite
    with munit.ScalaCheckEffectSuite
    with Generators {
  implicit private val logger: TestingLogger[IO] = TestingLogger.impl[IO]()
  implicit private def availabilityAlg: AvailabilityAlg[IO] = (_: Instant, _: Int) =&gt; IO(true)

  test(&quot;some state generates logs after persistence&quot;) {
    forAllF { (booking: Booking) =&gt;
      val acceptedBooking = booking.copy(status = Booking.Status.Accepted)
      for {
        effector &lt;- Effector.apply[IO, Booking, BookingAlg](
          new SelfEntity {},
          Some(acceptedBooking)
        )
        _ &lt;- new BookingSideEffect().apply(Trigger.AfterPersistence, effector)
        _ &lt;- assertIO(logger.logged.map(_.map(_.message).last), show&quot;State is now $acceptedBooking&quot;)
      } yield ()
    }
  }

  test(&quot;some state passivates after one hour&quot;) {
    forAllF { (booking: Booking, trigger: Trigger) =&gt;
      for {
        effector &lt;- Effector.apply[IO, Booking, BookingAlg](
          new SelfEntity {},
          Some(booking.copy(status = Booking.Status.Accepted))
        )
        _ &lt;- new BookingSideEffect().apply(trigger, effector)
        _ &lt;- assertIO(effector.passivationState, Effector.PassivationState.After(1.hour))
      } yield ()
    }
  }

  test(&quot;passivates immediately when cancelled&quot;) {
    forAllF { (booking: Booking, trigger: Trigger) =&gt;
      for {
        effector &lt;- Effector.apply[IO, Booking, BookingAlg](
          new SelfEntity {},
          Some(booking.copy(status = Booking.Status.Cancelled))
        )
        _ &lt;- new BookingSideEffect().apply(trigger, effector)
        _ &lt;- assertIO(effector.passivationState, PassivationState.After(Duration.Zero))
      } yield ()
    }
  }

  test(&quot;notifies availability when pending and does not passivate&quot;) {
    forAllF { (booking: Booking) =&gt;
      for {
        effector &lt;- Effector.apply[IO, Booking, BookingAlg](
          new SelfEntity {
            override def notifyCapacity(
                isAvailable: Boolean
            ): IO[BookingAlg.BookingUnknown.type \/ Unit] = {
              assert(isAvailable)
              IO.pure(().asRight)
            }
          },
          Some(booking.copy(status = Booking.Status.Pending))
        )
        _ &lt;- new BookingSideEffect().apply(Trigger.AfterPersistence, effector)
      } yield ()
    }
  }

  trait SelfEntity extends BookingAlg[IO] {
    lazy val raiseError = IO.raiseError(new RuntimeException(&quot;should not be called&quot;))

    override def place(
        bookingID: Booking.BookingID,
        time: Instant,
        passengerCount: Int,
        origin: LatLon,
        destination: LatLon
    ): IO[BookingAlg.BookingAlreadyExists \/ Unit] = raiseError
    override def get: IO[BookingAlg.BookingUnknown.type \/ Booking] = raiseError
    override def changeOrigin(newOrigin: LatLon): IO[BookingAlg.BookingUnknown.type \/ Unit] =
      raiseError
    override def changeDestination(
        newDestination: LatLon
    ): IO[BookingAlg.BookingUnknown.type \/ Unit] = raiseError
    override def changeOriginAndDestination(
        newOrigin: LatLon,
        newDestination: LatLon
    ): IO[BookingAlg.BookingUnknown.type \/ Unit] = raiseError
    override def cancel: IO[BookingAlg.CancelError \/ Unit] = raiseError
    override def notifyCapacity(isAvailable: Boolean): IO[BookingAlg.BookingUnknown.type \/ Unit] =
      raiseError
  }

}</code></pre>
<p>Command protocol can be also be covered in isolation with synchronous round-trip tests:</p>
<pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/endless4s/endless/tree/v0.29.0/example/src/test/scala/endless/example/protocol/BookingCommandProtocolSuite.scala#L16-L43" target="_blank" title="Go to snippet source">source</a><code class="language-scala">class BookingCommandProtocolSuite extends munit.ScalaCheckSuite with Generators {

  test(&quot;place booking&quot;) {
    forAll { (booking: Booking, reply: BookingAlg.BookingAlreadyExists \/ Unit) =&gt;
      implicit val sender: CommandSender[Id, Booking.BookingID] = CommandSender.local(
        protocol,
        new TestBookingAlg {
          override def place(
              bookingID: Booking.BookingID,
              time: Instant,
              passengerCount: Int,
              origin: LatLon,
              destination: LatLon
          ): Id[BookingAlg.BookingAlreadyExists \/ Unit] = reply
        }
      )
      val actualReply = protocol
        .clientFor(booking.id)
        .place(
          booking.id,
          booking.time,
          booking.passengerCount,
          booking.origin,
          booking.destination
        )
      assertEquals(actualReply, reply)
    }
  }</code></pre>
<p>Component and integration tests using Akka or Pekko testkits are also advisable and work as usual, see <a href="https://github.com/endless4s/endless/tree/v0.29.0/example/src/test/scala/endless/example/PekkoExampleAppSuite.scala">PekkoExampleAppSuite</a>.</p>
</div>
<div>
<a href="https://github.com/endless4s/endless/tree/v0.29.0/documentation/src/main/paradox/example.md" title="Edit this page" class="md-source-file md-edit">
Edit this page
</a>
</div>
<div class="print-only">
<span class="md-source-file md-version">
0.29.0
</span>
</div>
</article>
</div>
</div>
</main>
<footer class="md-footer">
<div class="md-footer-nav">
<nav class="md-footer-nav__inner md-grid">
<a href="runtime.html" title="Pekko and Akka runtimes" class="md-flex md-footer-nav__link md-footer-nav__link--prev" rel="prev">
<div class="md-flex__cell md-flex__cell--shrink">
<i class="md-icon md-icon--arrow-back md-footer-nav__button"></i>
</div>
<div class="md-flex__cell md-flex__cell--stretch md-footer-nav__title">
<span class="md-flex__ellipsis">
<span class="md-footer-nav__direction">
Previous
</span>
Pekko and Akka runtimes
</span>
</div>
</a>
<a href="reference.html" title="Reference" class="md-flex md-footer-nav__link md-footer-nav__link--next" rel="next">
<div class="md-flex__cell md-flex__cell--stretch md-footer-nav__title">
<span class="md-flex__ellipsis">
<span class="md-footer-nav__direction">
Next
</span>
Reference
</span>
</div>
<div class="md-flex__cell md-flex__cell--shrink">
<i class="md-icon md-icon--arrow-forward md-footer-nav__button"></i>
</div>
</a>
</nav>
</div>
<div class="md-footer-meta md-typeset">
<div class="md-footer-meta__inner md-grid">
<div class="md-footer-copyright">
Powered by
<a href="https://github.com/lightbend/paradox">Paradox</a>
and
<a href="https://jonas.github.io/paradox-material-theme/">Paradox Material Theme</a>

</div>
<div class="md-footer-social">
<a href="https://github.com/endless4s/endless" class="md-footer-social__link fa fa-github"></a>
</div>

</div>
</div>
</footer>

</div>
<script src="assets/javascripts/application.583bbe55.js"></script>
<script src="assets/javascripts/paradox-material-theme.js"></script>
<script>app.initialize({version:"0.17",url:{base:"."}})</script>
<script type="text/javascript" src="lib/prettify/prettify.js"></script>
<script type="text/javascript" src="lib/prettify/lang-scala.js"></script>
<script type="text/javascript">
document.addEventListener("DOMContentLoaded", function(event) {
window.prettyPrint && prettyPrint();
});
</script>
<script>!function(e,a,t,n,o,c,i){e.GoogleAnalyticsObject=o,e.ga=e.ga||function(){(e.ga.q=e.ga.q||[]).push(arguments)},e.ga.l=1*new Date,c=a.createElement(t),i=a.getElementsByTagName(t)[0],c.async=1,c.src="https://www.google-analytics.com/analytics.js",i.parentNode.insertBefore(c,i)}(window,document,"script",0,"ga"),ga("create","G-KKHFXG4VB4"),ga("set","anonymizeIp",!0),ga("send","pageview");var links=document.getElementsByTagName("a");Array.prototype.map.call(links,function(e){e.host!=document.location.host&&e.addEventListener("click",function(){var a=e.getAttribute("data-md-action")||"follow";ga("send","event","outbound",a,e.href)})});if(document.forms.search){var query=document.forms.search.query;query.addEventListener("blur",function(){if(this.value){var e=document.location.pathname;ga("send","pageview",e+"?q="+this.value)}})}</script>

</body>
</html>