{"docs":[{"location":"/paradox.json","text":"","title":""},{"location":"/index.html","text":"endless is a library to build distributed systems in functional Scala using a pluggable runtime model (with built-in runtimes for Pekko & Akka).\n/ˈɛndləs/: having or seeming to have no end or limit endless refers to the ever flowing stream of events capturing state evolution with event sourcing, and is a nod to tag-less.","title":""},{"location":"/getting-started.html","text":"","title":"Getting Started ·"},{"location":"/getting-started.html#getting-started","text":"Add the following dependency to your build.sbt file:\nlibraryDependencies += \"io.github.endless4s\" %% \"endless-core\" % \"0.28.0\"\nThis will pull in the core endless module, containing typeclasses and interpreters. You should add this dependency to the project that contains your business domain logic (typically “domain”).\nPekko runtime is available in endless-runtime-pekko (for Akka, use endless-runtime-akka). There are also helpers for defining protobuf protocols in endless-protobuf-helpers, scodec in endless-scodec-helpers and circe in endless-circe-helpers. Add those dependencies to the project where your application wiring code resides (typically “infrastructure”).\nYou can also clone this repository and run the example application with sbt run.\nCompatibility Since Akka/Pekko does not allow mixed versions in a project, Akka/Pekko dependencies of endless-runtime-akka and endless-runtime-pekko respectively are marked a Provided. This means that your application libraryDependencies needs to directly include Akka or Pekko as a dependency. The minimal supported Akka version is 2.6.20, and Pekko version is 1.0.2.","title":"Getting Started"},{"location":"/nutshell.html","text":"","title":"In a nutshell ·"},{"location":"/nutshell.html#in-a-nutshell","text":"Endless bridges the gap between Cats Effect and Pekko/Akka Cluster Sharding. It makes it possible to define abstract repository and entity algebras in tagless-final style to describe distributed event sourced domains seamlessly within functional codebases. Writing applications using endless’s abstraction layer also makes it easy to switch between actor frameworks.\nImplementation of the various aspects of an entity can be done using endless typeclasses and abstractions:\nSharding: represents the ability to interact with a specific entity in the cluster Entity: ability to read entity state, write events and produce a reply (direct state persistence is supported with DurableEntity) EventApplier: description of how to fold events over entity state CommandProtocol: ability to translate entity algebra invocations into serializable commands and replies CommandSender: ability to deliver a command to its target entity, and provide the reply back to the sender (transport layer) Effector: ability to produce side effects after event persistence, including control of entity passivation and chaining further interactions with the entity itself\nThe provided Pekko/Akka runtimes are a thin layer over Cluster Sharding. They rely exclusively on the usual public APIs (the Persistence DSL in particular) and allow for full customization of the entity behavior if lower-level tweaks are required.\nGenericity Abstractions defined here are universal and could also be operated with a different event-sourcing framework or even a custom implementation. At the moment, built-in support for both Pekko and Akka is provided. A native implementation for Kubernetes is also in the works.\nFor more info Check out the blog article Functional event-sourcing with cats-effect","title":"In a nutshell"},{"location":"/abstractions.html","text":"","title":"Abstractions ·"},{"location":"/abstractions.html#abstractions","text":"All definitions make use of the following type parameters:\nF[_]: abstract effectful context F encapsulating all values, e.g. IO[Boolean] Alg[_[_]]: algebra allowing interaction with the entity, e.g. BookingAlg[IO[*]] RepositoryAlg[_[_]]: algebra allowing interaction with the repository, e.g. BookingsAlg[IO[*]] ID: entity ID, e.g. BookingID S: entity state, e.g. Booking E: entity event, e.g. BookingEvent","title":"Abstractions"},{"location":"/sharding.html","text":"","title":"Sharding ·"},{"location":"/sharding.html#sharding","text":"trait Sharding[F[_], ID, Alg[_[_]]] {\n  def entityFor(id: ID): Alg[F]\n}\nSharding is parametrized with entity ID type ID and entity algebra Alg[_[_]]. It represents the ability to obtain an instance of that algebra (the entity) for a specific ID. This operation represents location-transparent access to sharded entities in a distributed system. It is made available to the interpreter of the repository algebra (e.g. ShardedBookings).","title":"Sharding"},{"location":"/entity.html","text":"","title":"Entity ·"},{"location":"/entity.html#entity","text":"trait StateReader[F[_], S] {\n  def read: F[S]\n}\ntrait EventWriter[F[_], E] {\n  def write(event: E, other: E*): F[Unit]\n}\ntrait Entity[F[_], S, E] extends StateReader[F, S] with EventWriter[F, E]\nEntity is parametrized with entity state S and events E. It is a typeclass which represents reader-writer capabilities for F with event-sourcing semantics, i.e. the abilities to read current entity state from the context and persist events. Entity is used to describe entity behavior (e.g. BookingEntity).","title":"Entity"},{"location":"/entity.html#functional-event-sourcing","text":"Reader-writer is a natural fit for describing event sourcing behavior: the monadic chain represents event sequencing and corresponding evolution of the state (see also here and here).\nAdvantages of this abstraction are:\nthe command is the call and the reply is simply the final resulting value in the monadic chain, there are no explicit representations maximal composability since it’s just flatMap all the way down, making it easier to work with a reduced set of events read always provides the up-to-date state and event folding happens transparently behind the scenes pure & side-effect-free logic that is easy to test the algebra interpreter does not support asynchronicity or other such effects lower in the hierarchy, which makes it impossible to accidentally introduce them in the command handling logic\nResponsivity When defining event-sourced entities, it is considered best practice to process commands and formulate a reply quickly as it makes the system responsive. Long-running processes should only initiate as the result of events, which also has the added benefit that they can be restored upon recovery or be driven by a projection. See Effector to find out how to describe side effects with endless.\nAbout performance When composing a sequence of computations which has multiple writes with interspersed reads, the state is folded before each read by the interpreter. This is necessary to provide a constant version of the state during interpretation. This is an operation that the runtime (Pekko/Akka) will also do behind the scenes when evolving the entity state. Redundant invocations of the folding function can therefore occur with the elevated monadic abstraction. However, in most cases this overhead is insignificant: event application needs to be as fast and simple as possible as it is of course invoked repeatedly for each event during recovery any possible redundant folds only happens upon reception of a command, not upon recovery command handling behavior with multiple interspersed reads and writes is less frequent than the more common read-then-write pattern","title":"Functional event sourcing"},{"location":"/durable-entity.html","text":"","title":"Durable entity ·"},{"location":"/durable-entity.html#durable-entity","text":"trait StateReader[F[_], S] {\n  def read: F[S]\n}\ntrait StateWriter[F[_], S] {\n  def write(s: S): F[Unit]\n  def modify(f: S => S): F[Unit]\n  def modifyF(f: S => F[S]): F[Unit]\n}\ntrait DurableEntity[F[_], S]\n    extends StateReader[F, S]\n    with StateWriter[F, S]\nDurableEntity is parametrized with entity state S. It is a typeclass which represents reader-writer capabilities for F with direct state persistence semantics, i.e., the ability to store the full state after processing each command instead of a sequence of events.\nFor some use cases, e.g. in scenarios with high-frequency updates where each individual update doesn’t carry valuable meaning to the domain, events aren’t relevant and flashing the full state is preferable.\nSuch “durable” entities still benefit from sharding, passivation, rebalancing, automatic recovery etc. while keeping the persistence model simple. In effect, this is a way to implement CRUD-like distributed entities while retaining the advantages of actors, such as the ability to actively schedule side-effects, precise state-machine semantics, consistent distributed in-memory state, etc.","title":"Durable entity"},{"location":"/applier.html","text":"","title":"EventApplier ·"},{"location":"/applier.html#eventapplier","text":"trait EventApplier[S, E] extends ((Option[S], E) => String \\/ Option[S])\nApplication of an event on the entity state (aka. folding the events over the state) is defined with an EventApplier pure function, parametrized with the state S and events E. This is a tupled function of a possibly defined state and the event, leading to either a new version of the state or an error (\\/ is a type alias for Either).","title":"EventApplier"},{"location":"/protocol.html","text":"","title":"CommandProtocol ·"},{"location":"/protocol.html#commandprotocol","text":"trait CommandProtocol[Alg[_[_]]] {\n  def server[F[_]]: Decoder[IncomingCommand[F, Alg]]\n  def clientFor[F[_]](id: ID)(implicit sender: CommandSender[F, ID]): Alg[F]\n}\nCommandProtocol is to be implemented for each entity algebra. It provides an RPC-like client in charge of transforming calls into instances of OutgoingCommand, delivering such commands to the targeted entity using a CommandSender and decoding the reply. It also defines the corresponding server, which can decode commands into IncomingCommand instances, run the corresponding entity logic and encode the reply.\nOutgoingCommand is able to encode the command into a binary representation ready to be sent over the wire and also decode the expected subsequent reply. IncomingCommand is able to decode the incoming command, invoke the corresponding handler and encode the reply.\nIn other words, clientFor materializes algebra invocations into outgoing commands delivered to server, which acts as a switchboard for incoming commands. See BookingCommandProtocol for a concrete example.\nExplicit or implicit representations CommandProtocol is the entry point for implementations to map algebra entries to concrete commands and replies. Having these lower-level aspects described separately makes it easier to have precise control of versions and to deal with migration challenges. We provide helpers for definition of binary protocols in endless-protobuf-helpers as well as endless-scodec-helpers and JSON protocols in endless-circe-helpers. Definition of protobuf protocols is very convenient using endless-protobuf-helpers because scalaPB-generated types can be referenced directly, there is no need for a separate representation of commands (and associated data-mapping headaches).\nTesting Command protocols can be tested in isolation via synchronous round-trip exercise of the journey client invocation -> command materialization -> command encoding -> command decoding -> behavior invocation -> reply materialization -> reply encoding -> reply decoding. See BookingCommandProtocolSuite for an example.","title":"CommandProtocol"},{"location":"/sender.html","text":"","title":"CommandSender ·"},{"location":"/sender.html#commandsender","text":"trait CommandSender[F[_], ID] {\n  def senderForID(id: ID): OutgoingCommand[*] ~> F\n}\nCommandSender represents the ability to deliver a command to its target entity. It provides a natural transformation of OutgoingCommand types “back to” F, where the “transformation” is typically the flow of encoding/decoding and delivering command/responses in the cluster ultimately leading back to a F[A] reply value.\nIn other words, it implements the transport layer of the cluster, and is typically provided by the runtime.\nThe built-in implementations in Pekko and Akka runtimes simply rely on an actor ask: ShardingCommandSender","title":"CommandSender"},{"location":"/side-effect.html","text":"","title":"Side-effect ·"},{"location":"/side-effect.html#side-effect","text":"trait SideEffect[F[_], S, Alg[_[_]]] {\n  def apply(trigger: SideEffect.Trigger, effector: Effector[F, S, Alg]): F[Unit]\n}\nSideEffect is parametrized with the following type parameters:\nF[_]: abstract effectful context F encapsulating all values, e.g. IO[*] Alg[_[_]]: entity algebra, allowing “back-interaction” with the entity itself (e.g. for at least once process definition, see note in Effector) S: entity state, e.g. Booking\nIt represents a side-effect that is triggered according to trigger either after event persistence, command handling (for a read-only behavior invocation) or recovery. Side-effects are typically asynchronous operations such as kafka writes, outgoing REST requests, and entity passivation (flushing out of memory).\nIn the runtime, the resulting F[Unit] is interpreted with Async in run & forget mode so that command reply is not delayed by any lengthy side-effect. The passed Effector instance can be used to access entity state, chain further interactions with the entity itself and to control passivation (for an example, see BookingEffector\nNote Defining a side-effect is entirely optional, pass-in SideEffectInterpreter.unit in deployRepository if there are no side-effects to describe.","title":"Side-effect"},{"location":"/effector.html","text":"","title":"Effector ·"},{"location":"/effector.html#effector","text":"trait StateReader[F[_], S] {\n  def read: F[Option[S]]\n}\ntrait Passivator[F[_]] {\n  def enablePassivation(after: FiniteDuration = Duration.Zero): F[Unit]\n  def disablePassivation: F[Unit]\n}\ntrait Self[F[_], Alg[_[_]]] {\n  def self: Alg[F]\n}\ntrait Effector[F[_], S] extends StateReader[F, S] with Passivator[F] with Self[F]\nEffector is a typeclass used to describe side effects in the context of a SideEffect definition.","title":"Effector"},{"location":"/effector.html#state-derived-side-effects","text":"StateReader allows reading the updated entity state after event persistence or recovery.","title":"State-derived side-effects"},{"location":"/effector.html#passivation","text":"Passivator allow fine grain control over passivation. In certain domains, entities can evolve into “dormant” states (e.g. after a BookingCancelled event) for which it is beneficial to trigger passivation, either immediately or after a certain delay. This enables proactive optimization of cluster resources.","title":"Passivation"},{"location":"/effector.html#self-process-definition","text":"Self exposes the algebra of the entity. This allows definition of asynchronous processes that involve interaction with the very same entity, typically to define entities acting as process managers (see below for more detail).\nAt least once delivery with zero latency For most processes, at least once delivery guarantees are required. This can be achieved with a projection, however at the cost of some incurred latency. Actual latency depends on the database and event journal implementation used, as well as the projection throughput. One must also make sure to distribute the projection across the cluster to avoid creating a central choke point. Even so, if a projector process gets stalled for some reason, this can create a cascade effect with events pending processing building up. An effective alternative to using a projection is to track process completion in the entity state itself. Launching asynchronous operations directly as a side-effect of an event has zero latency overhead and also the added advantage that the process launches within the node of the entity which triggered it, thus benefiting from inherent distribution. By enabling remember-entities, we can achieve guaranteed at-least-once completion of asynchronous processes thanks to effector running right after recovery (thus withstanding node crash or shard rebalancing). endless makes it easy to implement this pattern with Self. Here’s the recipe, as illustrated in the example application example: BookingPlaced event gets persisted. At this point, entity state represents pending acceptation of the booking Booking(..., status = Pending) Effector function inspects the state, and in case of Pending status, asks a third-party service for availability and notifies the entity of the result: val availabilityProcess: Booking => F[Unit] = booking =>\n  booking.status match {\n    case Status.Pending =>\n      (availabilityAlg.isCapacityAvailable(\n        booking.time,\n        booking.passengerCount\n      ) >>= self.notifyCapacity).void\n    case _ => ().pure\n  }\n 3.BookingAccepted or BookingRejected events are persisted and entity state is updated accordingly.","title":"Self & process definition"},{"location":"/name.html","text":"","title":"EntityNameProvider ·"},{"location":"/name.html#entitynameprovider","text":"trait EntityNameProvider[ID] extends (() => String)\nEntityNameProvider simply provides the name (type name, or kind) of the entity, for a specific entity ID type. This maps to Akka/Pekko’s EntityTypeKey.name","title":"EntityNameProvider"},{"location":"/id.html","text":"","title":"EntityIDCodec ·"},{"location":"/id.html#entityidcodec","text":"trait EntityIDEncoder[-ID] {\n  def encode(id: ID): String\n}\ntrait EntityIDDecoder[+ID] {\n  def decode(id: String): ID\n}\ntrait EntityIDCodec[ID] extends EntityIDEncoder[ID] with EntityIDDecoder[ID]\nEntityIDCodec can encode/decode the entity ID into/from String for transmission over the wire together with commands.","title":"EntityIDCodec"},{"location":"/deployer.html","text":"","title":"Deployer ·"},{"location":"/deployer.html#deployer","text":"trait Deployer {\n  def deployRepository[F[_]: Async, ID: EntityIDCodec, S, E, Alg[_[_]], RepositoryAlg[_[_]]](\n      repository: RepositoryInterpreter[F, ID, Alg, RepositoryAlg],\n      behavior: BehaviorInterpreter[F, S, E, Alg],\n      sideEffect: SideEffectInterpreter[F, S, Alg, RepositoryAlg]\n    )(implicit\n      nameProvider: EntityNameProvider[ID],\n      commandProtocol: CommandProtocol[ID, Alg],\n      eventApplier: EventApplier[S, E],\n      parameters: DeploymentParameters[F, ID, S, E]\n    ): Resource[F, Deployment[F, RepositoryAlg]]\n}\nDeployer brings everything together to “materialize” an entity repository. It returns a Deployment instance wrapped in a cats-effect Resource (to support finalization). The Deployment type is defined by implementers (aka. the runtime, e.g. PekkoDeployer), and is meant to provide a RepositoryAlg instance allowing for interactions with the deployed repository. It can also expose extra fields or methods that are relevant to the particular runtime.\ndeployRepository is parametrized with the following type parameters:\nF[_]: abstract effectful context F encapsulating all values, e.g. IO[*] Alg[_[_]]: algebra allowing interaction with the entity, e.g. BookingAlg[IO[*]] RepositoryAlg[_[_]]: repository algebra, e.g. BookingRepositoryAlg[IO[*]] ID: entity ID, e.g. final case class BookingID(id: UUID) extends AnyVal S: entity state, e.g. Booking E: entity event, e.g. BookingEvent\nRepository operation is defined by the interpreted repository, behavior and side-effect algebras, following a strictly defined sequence:\nthe interpreted repository is used to create a handle on the entity with the specified ID. This handle implements the entity algebra, using which the caller can interact with the entity. when a function of the entity algebra is invoked, the invocation is serialized using the commandProtocol and sent over the wire thanks to CommandSender. It is then decoded on the server side and run with the provided behavior interpreter: this typically involves reading the entity state (e.g. for validation) and writing events (which leads to a new version of the state via the eventApplier folding function) after events are written, a possible side-effect is triggered: this supports asynchronicity (i.e. starting fibers) the function finally returns to the caller with the result of the operation, encoded over the wire as a reply using commandProtocol and delivered back to the caller thanks to CommandSender.\nSee also sequence diagrams in Example App that represent this flow for a concrete entity.","title":"Deployer"},{"location":"/runtime.html","text":"","title":"Pekko and Akka runtimes ·"},{"location":"/runtime.html#pekko-and-akka-runtimes","text":"Once required interpreters and typeclass instances have been defined, deploying an entity with Pekko or Akka boils down to a single call to deployRepository. This requires an actor system and the cluster sharding extension in implicit scope, bundled in the type PekkoCluster (or AkkaCluster). The recommended pattern is to use the built-in managedResource helper method to obtain an instance of this class, which wraps actor system creation and shutdown with a Resource.","title":"Pekko and Akka runtimes"},{"location":"/runtime.html#how-to-initiate-the-distributed-cluster","text":"The entrypoint is available by importing endless.runtime.pekko.syntax.deploy.* or endless.runtime.akka.syntax.deploy.* and calling deployRepository with the required parameters.\nThis function ties everything together and delivers a cats effect Resource with an instance of DeployedPekkoRepository in context F bundling the RepositoryAlg instance together with the ref to the shard region actor returned by the call to Pekko’s ClusterSharding.init.\nThe following snippet is the scaffolding for the library’s sample application (in its Pekko form), a simple API to manage vehicles and bookings:\ncopysourceResource\n  .eval(Slf4jLogger.create[IO])\n  .flatMap { implicit logger: Logger[IO] =>\n    PekkoCluster.managedResource[IO](actorSystem).flatMap {\n      implicit cluster: PekkoCluster[IO] =>\n        implicit val eventSourcingDeploymentParameters\n            : PekkoDeploymentParameters[IO, Booking, BookingEvent] =\n          PekkoDeploymentParameters[IO, Booking, BookingEvent](\n            customizeBehavior = (_, behavior) =>\n              behavior.eventAdapter(\n                new EventAdapter[\n                  BookingEvent,\n                  endless.example.proto.booking.events.BookingEvent\n                ] {\n                  def toJournal(\n                      e: BookingEvent\n                  ): endless.example.proto.booking.events.BookingEvent =\n                    eventAdapter.toJournal(e)\n\n                  def manifest(event: BookingEvent): String = event.getClass.getName\n\n                  def fromJournal(\n                      p: endless.example.proto.booking.events.BookingEvent,\n                      manifest: String\n                  ): EventSeq[BookingEvent] = EventSeq.single(eventAdapter.fromJournal(p))\n                }\n              )\n          )\n        implicit val durableDeploymentParameters\n            : PekkoDurableDeploymentParameters[IO, Vehicle] =\n          PekkoDurableDeploymentParameters[IO, Vehicle](\n            customizeBehavior = (_, behavior) =>\n              behavior.snapshotAdapter(new SnapshotAdapter[Option[Vehicle]] {\n                def toJournal(state: Option[Vehicle]): Any = stateAdapter.toJournal(state)\n                def fromJournal(from: Any): Option[Vehicle] = stateAdapter.fromJournal(from)\n              })\n          )\n        Resource\n          .both(\n            deployRepository[\n              IO,\n              BookingID,\n              Booking,\n              BookingEvent,\n              BookingAlg,\n              BookingsAlg\n            ](\n              RepositoryInterpreter.lift(ShardedBookings(_)),\n              BehaviorInterpreter.lift(BookingEntityBehavior(_)),\n              SideEffectInterpreter.lift { case (_, _) => new BookingSideEffect() }\n            ),\n            deployDurableRepository[IO, VehicleID, Vehicle, VehicleAlg, VehiclesAlg](\n              RepositoryInterpreter.lift(ShardedVehicles(_)),\n              DurableBehaviorInterpreter.lift(VehicleEntityBehavior(_)),\n              SideEffectInterpreter.lift { case (_, _) => new VehicleSideEffect() }\n            )\n          )\n          .flatMap { case (bookingDeployment, vehicleDeployment) =>\n            HttpServer(\n              port,\n              bookingDeployment.repository,\n              vehicleDeployment.repository,\n              cluster.isMemberUp\n            )\n          }\n    }\n  }\ndeployRepository is parameterized with the context F and the various involved types: S for entity state, E for events, ID for entity ID and Alg & RepositoryAlg for entity and repository algebras respectively (both higher-kinded type constructors).\nIn order to bridge Pekko/Akka’s implicit asynchronicity with the side-effect free context F used for algebras, it requires Async from F. This makes it possible to use the Dispatcher mechanism for running the command handling monadic chain synchronously from within the actor thread.\nLogger from log4cats is also required as the library supports basic logging capabilities.\nImportant deployRepository needs to be called upon application startup, before joining the cluster as the ClusterSharding extension needs to know about the various entity types beforehand.\nDurable entity The equivalent method for durable entities is deployDurableRepository.","title":"How to initiate the distributed cluster"},{"location":"/runtime.html#internals","text":"","title":"Internals"},{"location":"/runtime.html#protocol","text":"Thanks to the CommandProtocol instance, entity algebra calls can be “materialized” into concrete commands and replies. These types are encoded to a binary payload, which is transported within an internal protobuf envelope command.proto.\nShardingCommandSender takes care of delivering the commands to the right entity and returning the reply simply by using Pekko/Akka’s ask.","title":"Protocol"},{"location":"/runtime.html#deployer","text":"Internally, deployRepository uses EventSourcedBehavior DSL to configure the entity in the following way (for deployDurableRepository, this is DurableStateBehavior):","title":"Deployer"},{"location":"/runtime.html#command-handler","text":"use CommandProtocol.server to decode the command and invoke the corresponding algebra logic, interpreted internally with EntityT. Interpretation of the monadic chain occurs, leading to one or more events and a return value. hand in produced events to Pekko/Akka’s Effect.persist. trigger any side effects in Effector with a run-and-forget using Dispatcher from within thenRun encode the reply and feed it into thenReply","title":"Command handler"},{"location":"/runtime.html#event-handler","text":"This is simply a synchronous run of EventApplier (using Dispatcher). Left values are translated into thrown exceptions as Pekko/Akka doesn’t give us other means to deal with event handling errors.","title":"Event handler"},{"location":"/runtime.html#recovery","text":"Upon successful recovery, we log an info entry and run the effector, while we log a warning entry upon recovery failure.\nCustom behavior The built-in behavior is further customizable via a customizeBehavior function parameter that can be optionally passed into PekkoDeploymentParameters or AkkaDeploymentParameters.\nCompatibility Since Akka/Pekko does not allow mixed versions in a project, Akka/Pekko dependencies of endless-runtime-akka and endless-runtime-pekko respectively are marked a Provided. This means that your application libraryDependencies needs to directly include Akka or Pekko as a dependency. The minimal supported Akka version is 2.6.20, and Pekko version is 1.0.2.","title":"Recovery"},{"location":"/example.html","text":"","title":"Example app ·"},{"location":"/example.html#example-app","text":"Endless example application is a small API for managing imaginary bookings for passenger trips from some origin to some destination, as well as tracking positions and speeds of vehicles. It can be found in endless-example and can be run directly: sbt run.","title":"Example app"},{"location":"/example.html#api","text":"It has a simple CRUD API for bookings and vehicles:\ncopysource  HttpRoutes\n    .of[IO] {\n      case req @ POST -> Root / \"booking\"        => postBooking(bookingRepository, req)\n      case GET -> Root / \"booking\" / UUIDVar(id) => getBooking(bookingRepository, id)\n      case req @ PATCH -> Root / \"booking\" / UUIDVar(id) =>\n        patchBooking(bookingRepository, req, id)\n      case POST -> Root / \"booking\" / UUIDVar(id) / \"cancel\" =>\n        cancelBooking(bookingRepository, id)\n      case GET -> Root / \"vehicle\" / UUIDVar(id) / \"speed\" =>\n        getVehicleSpeed(vehicleRepository, id)\n      case GET -> Root / \"vehicle\" / UUIDVar(id) / \"position\" =>\n        getVehiclePosition(vehicleRepository, id)\n      case GET -> Root / \"vehicle\" / UUIDVar(id) / \"recoveryCount\" =>\n        getVehicleRecoveryCount(vehicleRepository, id)\n      case req @ POST -> Root / \"vehicle\" / UUIDVar(id) / \"speed\" =>\n        setVehicleSpeed(vehicleRepository, id, req)\n      case req @ POST -> Root / \"vehicle\" / UUIDVar(id) / \"position\" =>\n        setVehiclePosition(vehicleRepository, id, req)\n      case GET -> Root / \"health\" =>\n        isUp.flatMap {\n          case true  => Ok(\"OK\")\n          case false => ServiceUnavailable(\"Cluster member is down\")\n        }\n    }\n    .orNotFound\n)","title":"API"},{"location":"/example.html#scaffolding","text":"The application is assembled via calls to deployRepository (for bookings) and deployDurableEntity (for vehicles) (see runtime for more details)\nAkka and Pekko runtimes essentially have the same API, so we’ll use Pekko for the example:\ncopysourceResource\n  .eval(Slf4jLogger.create[IO])\n  .flatMap { implicit logger: Logger[IO] =>\n    PekkoCluster.managedResource[IO](actorSystem).flatMap {\n      implicit cluster: PekkoCluster[IO] =>\n        implicit val eventSourcingDeploymentParameters\n            : PekkoDeploymentParameters[IO, Booking, BookingEvent] =\n          PekkoDeploymentParameters[IO, Booking, BookingEvent](\n            customizeBehavior = (_, behavior) =>\n              behavior.eventAdapter(\n                new EventAdapter[\n                  BookingEvent,\n                  endless.example.proto.booking.events.BookingEvent\n                ] {\n                  def toJournal(\n                      e: BookingEvent\n                  ): endless.example.proto.booking.events.BookingEvent =\n                    eventAdapter.toJournal(e)\n\n                  def manifest(event: BookingEvent): String = event.getClass.getName\n\n                  def fromJournal(\n                      p: endless.example.proto.booking.events.BookingEvent,\n                      manifest: String\n                  ): EventSeq[BookingEvent] = EventSeq.single(eventAdapter.fromJournal(p))\n                }\n              )\n          )\n        implicit val durableDeploymentParameters\n            : PekkoDurableDeploymentParameters[IO, Vehicle] =\n          PekkoDurableDeploymentParameters[IO, Vehicle](\n            customizeBehavior = (_, behavior) =>\n              behavior.snapshotAdapter(new SnapshotAdapter[Option[Vehicle]] {\n                def toJournal(state: Option[Vehicle]): Any = stateAdapter.toJournal(state)\n                def fromJournal(from: Any): Option[Vehicle] = stateAdapter.fromJournal(from)\n              })\n          )\n        Resource\n          .both(\n            deployRepository[\n              IO,\n              BookingID,\n              Booking,\n              BookingEvent,\n              BookingAlg,\n              BookingsAlg\n            ](\n              RepositoryInterpreter.lift(ShardedBookings(_)),\n              BehaviorInterpreter.lift(BookingEntityBehavior(_)),\n              SideEffectInterpreter.lift { case (_, _) => new BookingSideEffect() }\n            ),\n            deployDurableRepository[IO, VehicleID, Vehicle, VehicleAlg, VehiclesAlg](\n              RepositoryInterpreter.lift(ShardedVehicles(_)),\n              DurableBehaviorInterpreter.lift(VehicleEntityBehavior(_)),\n              SideEffectInterpreter.lift { case (_, _) => new VehicleSideEffect() }\n            )\n          )\n          .flatMap { case (bookingDeployment, vehicleDeployment) =>\n            HttpServer(\n              port,\n              bookingDeployment.repository,\n              vehicleDeployment.repository,\n              cluster.isMemberUp\n            )\n          }\n    }\n  }","title":"Scaffolding"},{"location":"/example.html#algebras","text":"You might have spotted the two algebra types in the snippet above:","title":"Algebras"},{"location":"/example.html#repository","text":"copysourcetrait BookingsAlg[F[_]] {\n  def bookingFor(bookingID: BookingID): BookingAlg[F]\n}\nHere’s the sequence of operations happening behind the scenes when retrieving an instance of entity algebra:","title":"Repository"},{"location":"/example.html#entity","text":"copysourcetrait BookingAlg[F[_]] {\n  def place(\n      bookingID: BookingID,\n      time: Instant,\n      passengerCount: Int,\n      origin: LatLon,\n      destination: LatLon\n  ): F[BookingAlreadyExists \\/ Unit]\n  def get: F[BookingUnknown.type \\/ Booking]\n  def changeOrigin(newOrigin: LatLon): F[BookingUnknown.type \\/ Unit]\n  def changeDestination(newDestination: LatLon): F[BookingUnknown.type \\/ Unit]\n  def changeOriginAndDestination(\n      newOrigin: LatLon,\n      newDestination: LatLon\n  ): F[BookingUnknown.type \\/ Unit]\n  def cancel: F[CancelError \\/ Unit]\n  def notifyCapacity(isAvailable: Boolean): F[BookingUnknown.type \\/ Unit]\n}","title":"Entity"},{"location":"/example.html#implementations","text":"Implementation of the repository algebra is trivial using Sharding instance (injected by deployRepository):\ncopysourcefinal case class ShardedBookings[F[_]: Monad](sharding: Sharding[F, BookingID, BookingAlg])\n    extends BookingsAlg[F] {\n  def bookingFor(bookingID: BookingID): BookingAlg[F] = sharding.entityFor(bookingID)\n}\nImplementation of behavior algebra is done using the Entity typeclass instance (also injected by deployRepository):\ncopysourcefinal case class BookingEntityBehavior[F[_]: Logger: Clock](\n    entity: Entity[F, Booking, BookingEvent]\n) extends BookingAlg[F] {\n  import entity.*\n\n  def place(\n      bookingID: BookingID,\n      time: Instant,\n      passengerCount: Int,\n      origin: LatLon,\n      destination: LatLon\n  ): F[BookingAlreadyExists \\/ Unit] =\n    ifUnknownF(\n      Logger[F].info(show\"Creating booking with ID $bookingID\") >> write(\n        BookingPlaced(bookingID, time, origin, destination, passengerCount)\n      )\n    )(_ => BookingAlreadyExists(bookingID))\n\n  def get: F[BookingUnknown.type \\/ Booking] = ifKnown(identity)(BookingUnknown)\n\n  def changeOrigin(newOrigin: LatLon): F[BookingUnknown.type \\/ Unit] =\n    ifKnownF(booking =>\n      if (booking.origin =!= newOrigin) entity.write(OriginChanged(newOrigin)) else ().pure\n    )(BookingUnknown)\n\n  def changeDestination(newDestination: LatLon): F[BookingUnknown.type \\/ Unit] =\n    ifKnownF(booking =>\n      if (booking.destination =!= newDestination) entity.write(DestinationChanged(newDestination))\n      else ().pure\n    )(BookingUnknown)\n\n  def changeOriginAndDestination(\n      newOrigin: LatLon,\n      newDestination: LatLon\n  ): F[BookingUnknown.type \\/ Unit] = changeOrigin(newOrigin) >> changeDestination(newDestination)\n\n  def cancel: F[CancelError \\/ Unit] =\n    ifKnownT[CancelError, Unit](booking =>\n      booking.status match {\n        case Status.Accepted | Status.Pending =>\n          EitherT.liftF(\n            (Clock[F].realTimeInstant >>= (timestamp =>\n              Logger[F]\n                .info(show\"Cancelling booking with ID ${booking.id} at ${timestamp.toString}\")\n            )) >> entity.write(BookingCancelled)\n          )\n        case Status.Cancelled => EitherT.pure(())\n        case Status.Rejected  => EitherT.leftT[F, Unit](BookingAlg.BookingWasRejected(booking.id))\n      }\n    )(\n      BookingUnknown\n    )\n\n  def notifyCapacity(isAvailable: Boolean): F[BookingAlg.BookingUnknown.type \\/ Unit] =\n    ifKnownF(_.status match {\n      case Status.Pending =>\n        if (isAvailable) entity.write(BookingAccepted) else entity.write(BookingRejected)\n      case _ => ().pure\n    })(\n      BookingUnknown\n    )\n}","title":"Implementations"},{"location":"/example.html#event-handling","text":"In this simple example, events essentially set fields in the state:\ncopysourceclass BookingEventApplier extends EventApplier[Booking, BookingEvent] {\n  def apply(state: Option[Booking], event: BookingEvent): String \\/ Option[Booking] =\n    (event match {\n      case BookingPlaced(bookingID, time, origin, destination, passengerCount) =>\n        state\n          .toLeft(Booking(bookingID, time, origin, destination, passengerCount))\n          .leftMap(_ => \"Booking already exists\")\n      case OriginChanged(newOrigin) =>\n        state\n          .toRight(\"Attempt to change unknown booking\")\n          .map(_.copy(origin = newOrigin))\n      case DestinationChanged(newDestination) =>\n        state\n          .toRight(\"Attempt to change unknown booking\")\n          .map(_.copy(destination = newDestination))\n      case BookingAccepted =>\n        state\n          .toRight(\"Attempt to accept unknown booking\")\n          .map(_.copy(status = Booking.Status.Accepted))\n      case BookingRejected =>\n        state\n          .toRight(\"Attempt to reject unknown booking\")\n          .map(_.copy(status = Booking.Status.Rejected))\n      case BookingCancelled =>\n        state\n          .toRight(\"Attempt to cancel unknown booking\")\n          .map(_.copy(status = Booking.Status.Cancelled))\n    }).map(Option(_))\n}","title":"Event handling"},{"location":"/example.html#protocol","text":"Command and reply encoding/decoding on client and server side is implemented with a subclass of CommandProtocol, in this case ProtobufCommandProtocol as we’ll be using protobuf. On the client side, we translate invocations into instances of OutgoingCommand and make use of the sendCommand helper function:\ncopysourceclass BookingCommandProtocol extends ProtobufCommandProtocol[BookingID, BookingAlg] {\n  override def clientFor[F[_]](\n      id: BookingID\n  )(implicit sender: CommandSender[F, BookingID]): BookingAlg[F] =\n    new BookingAlg[F] {\n      def place(\n          bookingID: BookingID,\n          time: Instant,\n          passengerCount: Int,\n          origin: LatLon,\n          destination: LatLon\n      ): F[BookingAlreadyExists \\/ Unit] =\n        sendCommand[F, BookingCommand, replies.PlaceBookingReply, BookingAlreadyExists \\/ Unit](\n          id,\n          BookingCommand.of(\n            Command.PlaceBookingV1(\n              PlaceBookingV1(\n                proto.BookingID(bookingID.show),\n                Timestamp.of(time.getEpochSecond, time.getNano),\n                passengerCount,\n                proto.LatLonV1(origin.lat, origin.lon),\n                proto.LatLonV1(destination.lat, destination.lon)\n              )\n            )\n          ),\n          {\n            case replies\n                  .PlaceBookingReply(replies.PlaceBookingReply.Reply.AlreadyExists(booking), _) =>\n              Left(BookingAlreadyExists(BookingID(UUID.fromString(booking.bookingId.value))))\n            case replies.PlaceBookingReply(replies.PlaceBookingReply.Reply.Unit(_), _) => Right(())\n            case replies.PlaceBookingReply(replies.PlaceBookingReply.Reply.Empty, _) =>\n              throw new UnexpectedReplyException\n          }\n        )\n\n      // ...\nOn the server side, we decode instances of IncomingCommand and make use of handleCommand to trigger relevant entity logic and encode the reply:\ncopysourceoverride def server[F[_]]: Decoder[IncomingCommand[F, BookingAlg]] =\n  ProtobufDecoder[BookingCommand].map(_.command match {\n    case Command.Empty => throw new UnexpectedCommandException\n    case Command.PlaceBookingV1(\n          PlaceBookingV1(bookingID, time, passengerCount, origin, destination, _)\n        ) =>\n      handleCommand[F, replies.PlaceBookingReply, BookingAlreadyExists \\/ Unit](\n        _.place(\n          BookingID(UUID.fromString(bookingID.value)),\n          Instant.ofEpochSecond(time.seconds, time.nanos),\n          passengerCount,\n          LatLon(origin.lat, origin.lon),\n          LatLon(destination.lat, destination.lon)\n        ),\n        {\n          case Left(bookingAlreadyExists) =>\n            replies.PlaceBookingReply(\n              replies.PlaceBookingReply.Reply.AlreadyExists(\n                replies.BookingAlreadyExistsV1(\n                  proto.BookingID(bookingAlreadyExists.bookingID.show)\n                )\n              )\n            )\n          case Right(_) =>\n            replies.PlaceBookingReply(replies.PlaceBookingReply.Reply.Unit(UnitReply()))\n        }\n      )\nHere’s an illustration of the chain of interactions taking place when placing a booking, both from the client and the server side:","title":"Protocol"},{"location":"/example.html#side-effects","text":"We describe the availability process as well as entity passivation using Effector:\ncopysourceclass BookingSideEffect[F[_]: Logger: Monad]()(implicit\n    availabilityAlg: AvailabilityAlg[F]\n) extends SideEffect[F, Booking, BookingAlg] {\n  def apply(trigger: Trigger, effector: Effector[F, Booking, BookingAlg]): F[Unit] = {\n    import effector.*\n\n    val availabilityProcess: Booking => F[Unit] = booking =>\n      (booking.status, trigger) match {\n        case (Status.Pending, Trigger.AfterRecovery | Trigger.AfterPersistence) =>\n          (availabilityAlg.isCapacityAvailable(\n            booking.time,\n            booking.passengerCount\n          ) >>= self.notifyCapacity).void\n        case _ => ().pure\n      }\n\n    val handlePassivation: Booking => F[Unit] = {\n      _.status match {\n        case Status.Pending   => Applicative[F].unit\n        case Status.Accepted  => enablePassivation(passivationDelay)\n        case Status.Rejected  => enablePassivation()\n        case Status.Cancelled => enablePassivation()\n      }\n    }\n\n    ifKnown(booking => Logger[F].info(show\"State is now $booking\")) >> ifKnown(\n      availabilityProcess\n    ) >> ifKnown(handlePassivation)\n  }\n\n  private val passivationDelay = 1.hour\n}","title":"Side-effects"},{"location":"/example.html#testing","text":"Unit testing for entity algebra implementation, event handling and effector benefits from to the parametric nature of F:\ncopysourceclass BookingEntityBehaviorSuite\n    extends munit.CatsEffectSuite\n    with munit.ScalaCheckEffectSuite\n    with Generators {\n  implicit private val logger: TestingLogger[IO] = TestingLogger.impl[IO]()\n  private val bookingAlg = BookingEntityBehavior(EntityT.instance[IO, Booking, BookingEvent])\n  private implicit val eventApplier: BookingEventApplier = new BookingEventApplier\n\n  test(\"place booking\") {\n    forAllF { (booking: Booking) =>\n      bookingAlg\n        .place(\n          booking.id,\n          booking.time,\n          booking.passengerCount,\n          booking.origin,\n          booking.destination\n        )\n        .run(None)\n        .map {\n          case Right((events, _)) =>\n            assertEquals(\n              events,\n              Chain(\n                BookingPlaced(\n                  booking.id,\n                  booking.time,\n                  booking.origin,\n                  booking.destination,\n                  booking.passengerCount\n                )\n              )\n            )\n          case Left(error) => fail(error)\n        }\n        .flatMap(_ => assertIOBoolean(logger.logged.map(_.nonEmpty)))\n    }\n  }\n\n  test(\"change origin and destination\") {\n    forAllF { (booking: Booking, newOrigin: LatLon, newDestination: LatLon) =>\n      bookingAlg\n        .changeOriginAndDestination(newOrigin, newDestination)\n        .run(Some(booking))\n        .map {\n          case Right((events, _)) =>\n            assertEquals(\n              events,\n              Chain[BookingEvent](OriginChanged(newOrigin), DestinationChanged(newDestination))\n            )\n          case _ => fail(\"unexpected\")\n        }\n    }\n  }\ncopysourceclass BookingEventApplierSuite extends munit.ScalaCheckSuite with Generators {\n  property(\"booking placed when unknown\") {\n    forAll { (booking: Booking) =>\n      val fold = new BookingEventApplier()(\n        None,\n        BookingPlaced(\n          booking.id,\n          booking.time,\n          booking.origin,\n          booking.destination,\n          booking.passengerCount\n        )\n      )\n      assertEquals(fold, Right(Some(booking)))\n    }\n  }\n\n  property(\"booking placed when known\") {\n    forAll { (booking: Booking) =>\n      val fold = new BookingEventApplier()(\n        Some(booking),\n        BookingPlaced(\n          booking.id,\n          booking.time,\n          booking.origin,\n          booking.destination,\n          booking.passengerCount\n        )\n      )\n      assert(fold.isLeft)\n    }\n  }\n\n  property(\"origin changed when known\") {\n    forAll { (booking: Booking, newOrigin: LatLon) =>\n      val fold = new BookingEventApplier()(Some(booking), OriginChanged(newOrigin))\n      assertEquals(fold.toOption.flatMap(_.map(_.origin)), Option(newOrigin))\n    }\n  }\n\n  property(\"origin changed when unknown\") {\n    forAll { (newOrigin: LatLon) =>\n      val fold = new BookingEventApplier()(None, OriginChanged(newOrigin))\n      assert(fold.isLeft)\n    }\n  }\n\n  property(\"destination changed when known\") {\n    forAll { (booking: Booking, newDestination: LatLon) =>\n      val fold = new BookingEventApplier()(Some(booking), DestinationChanged(newDestination))\n      assertEquals(fold.toOption.flatMap(_.map(_.destination)), Option(newDestination))\n    }\n  }\n\n  property(\"destination changed when unknown\") {\n    forAll { (newDestination: LatLon) =>\n      val fold = new BookingEventApplier()(None, DestinationChanged(newDestination))\n      assert(fold.isLeft)\n    }\n  }\n\n  property(\"booking accepted when known\") {\n    forAll { (booking: Booking) =>\n      val fold = new BookingEventApplier()(Some(booking), BookingAccepted)\n      assertEquals(fold.toOption.flatMap(_.map(_.status)), Option(Booking.Status.Accepted))\n    }\n  }\n\n  test(\"booking accepted when unknown\") {\n    val fold = new BookingEventApplier()(None, BookingAccepted)\n    assert(fold.isLeft)\n  }\n\n  property(\"booking rejected when known\") {\n    forAll { (booking: Booking) =>\n      val fold = new BookingEventApplier()(Some(booking), BookingRejected)\n      assertEquals(fold.toOption.flatMap(_.map(_.status)), Option(Booking.Status.Rejected))\n    }\n  }\n\n  test(\"booking rejected when unknown\") {\n    val fold = new BookingEventApplier()(None, BookingRejected)\n    assert(fold.isLeft)\n  }\n\n  property(\"booking cancelled when known\") {\n    forAll { (booking: Booking) =>\n      val fold = new BookingEventApplier()(Some(booking), BookingCancelled)\n      assertEquals(fold.toOption.flatMap(_.map(_.status)), Option(Booking.Status.Cancelled))\n    }\n  }\n\n  test(\"booking cancelled when unknown\") {\n    val fold = new BookingEventApplier()(None, BookingCancelled)\n    assert(fold.isLeft)\n  }\n}\ncopysourceclass BookingSideEffectSuite\n    extends munit.CatsEffectSuite\n    with munit.ScalaCheckEffectSuite\n    with Generators {\n  implicit private val logger: TestingLogger[IO] = TestingLogger.impl[IO]()\n  implicit private def availabilityAlg: AvailabilityAlg[IO] = (_: Instant, _: Int) => IO(true)\n\n  test(\"some state generates logs after persistence\") {\n    forAllF { (booking: Booking) =>\n      val acceptedBooking = booking.copy(status = Booking.Status.Accepted)\n      for {\n        effector <- Effector.apply[IO, Booking, BookingAlg](\n          new SelfEntity {},\n          Some(acceptedBooking)\n        )\n        _ <- new BookingSideEffect().apply(Trigger.AfterPersistence, effector)\n        _ <- assertIO(logger.logged.map(_.map(_.message).last), show\"State is now $acceptedBooking\")\n      } yield ()\n    }\n  }\n\n  test(\"some state passivates after one hour\") {\n    forAllF { (booking: Booking, trigger: Trigger) =>\n      for {\n        effector <- Effector.apply[IO, Booking, BookingAlg](\n          new SelfEntity {},\n          Some(booking.copy(status = Booking.Status.Accepted))\n        )\n        _ <- new BookingSideEffect().apply(trigger, effector)\n        _ <- assertIO(effector.passivationState, Effector.PassivationState.After(1.hour))\n      } yield ()\n    }\n  }\n\n  test(\"passivates immediately when cancelled\") {\n    forAllF { (booking: Booking, trigger: Trigger) =>\n      for {\n        effector <- Effector.apply[IO, Booking, BookingAlg](\n          new SelfEntity {},\n          Some(booking.copy(status = Booking.Status.Cancelled))\n        )\n        _ <- new BookingSideEffect().apply(trigger, effector)\n        _ <- assertIO(effector.passivationState, PassivationState.After(Duration.Zero))\n      } yield ()\n    }\n  }\n\n  test(\"notifies availability when pending and does not passivate\") {\n    forAllF { (booking: Booking) =>\n      for {\n        effector <- Effector.apply[IO, Booking, BookingAlg](\n          new SelfEntity {\n            override def notifyCapacity(\n                isAvailable: Boolean\n            ): IO[BookingAlg.BookingUnknown.type \\/ Unit] = {\n              assert(isAvailable)\n              IO.pure(().asRight)\n            }\n          },\n          Some(booking.copy(status = Booking.Status.Pending))\n        )\n        _ <- new BookingSideEffect().apply(Trigger.AfterPersistence, effector)\n      } yield ()\n    }\n  }\n\n  trait SelfEntity extends BookingAlg[IO] {\n    lazy val raiseError = IO.raiseError(new RuntimeException(\"should not be called\"))\n\n    override def place(\n        bookingID: Booking.BookingID,\n        time: Instant,\n        passengerCount: Int,\n        origin: LatLon,\n        destination: LatLon\n    ): IO[BookingAlg.BookingAlreadyExists \\/ Unit] = raiseError\n    override def get: IO[BookingAlg.BookingUnknown.type \\/ Booking] = raiseError\n    override def changeOrigin(newOrigin: LatLon): IO[BookingAlg.BookingUnknown.type \\/ Unit] =\n      raiseError\n    override def changeDestination(\n        newDestination: LatLon\n    ): IO[BookingAlg.BookingUnknown.type \\/ Unit] = raiseError\n    override def changeOriginAndDestination(\n        newOrigin: LatLon,\n        newDestination: LatLon\n    ): IO[BookingAlg.BookingUnknown.type \\/ Unit] = raiseError\n    override def cancel: IO[BookingAlg.CancelError \\/ Unit] = raiseError\n    override def notifyCapacity(isAvailable: Boolean): IO[BookingAlg.BookingUnknown.type \\/ Unit] =\n      raiseError\n  }\n\n}\nCommand protocol can be also be covered in isolation with synchronous round-trip tests:\ncopysourceclass BookingCommandProtocolSuite extends munit.ScalaCheckSuite with Generators {\n\n  test(\"place booking\") {\n    forAll { (booking: Booking, reply: BookingAlg.BookingAlreadyExists \\/ Unit) =>\n      implicit val sender: CommandSender[Id, Booking.BookingID] = CommandSender.local(\n        protocol,\n        new TestBookingAlg {\n          override def place(\n              bookingID: Booking.BookingID,\n              time: Instant,\n              passengerCount: Int,\n              origin: LatLon,\n              destination: LatLon\n          ): Id[BookingAlg.BookingAlreadyExists \\/ Unit] = reply\n        }\n      )\n      val actualReply = protocol\n        .clientFor(booking.id)\n        .place(\n          booking.id,\n          booking.time,\n          booking.passengerCount,\n          booking.origin,\n          booking.destination\n        )\n      assertEquals(actualReply, reply)\n    }\n  }\nComponent and integration tests using Akka or Pekko testkits are also advisable and work as usual, see PekkoExampleAppSuite.","title":"Testing"},{"location":"/reference.html","text":"","title":"Reference ·"},{"location":"/reference.html#reference","text":"Core API documentation Akka Runtime API documentation Pekko Runtime API documentation Endless protobuf helpers API documentation Endless circe helpers API documentation Endless scodec helpers API documentation","title":"Reference"},{"location":"/inspiration.html","text":"","title":"Inspiration ·"},{"location":"/inspiration.html#inspiration","text":"Our journey towards elevation of our event-sourcing code abstraction level started with an inheritance-based model, that we described in this article. We introduced EntityCommand and EntityEvent traits, which allowed us in turn to define someCommandProcessor and EventApplier constructs with generic implementations and mappings for Akka. This was already a good step in the right direction as it allowed us to host command handling and event handling logic in the domain, free from any Pekko/Akka dependencies.","title":"Inspiration"},{"location":"/inspiration.html#implicit-commands-replies","text":"However, with this approach, commands and replies are still an integral part of the domain model. And if you think about it, such models and associated mappings to/from values do not add any value to domain expression, rather the contrary. Domain code is more compact if we can use straight algebras and values, without concern for the underlying necessary reification to cross node boundaries in the cluster. It was also always an open question for us how to best integrate event sourcing within functional codebases. Since event-sourcing looks a lot like a reader-writer monad, we felt there was some potential there.","title":"Implicit commands & replies"},{"location":"/inspiration.html#aecor","text":"At this point, we ran into the outstanding work done by Denis Mikhaylov & contributors on Aecor as well as the excellent blog series by Vladimir Pavkin. This was an eye-opener, and we highly recommend the read!\nHowever, we could not use the library directly for a number of reasons, chiefly because we are attached to keeping the layer above Pekko/Akka as lightweight as possible and we want to keep control on serialization aspects. There also are other more subtle differences: for instance we consider command rejections (and more generally, “business errors”) as first-order values, therefore opting for Either for replies. In endless, we’ve also tried to stick close to DDD & Pekko/Akka nomenclature as much as possible.","title":"Aecor"},{"location":"/inspiration.html#bridging-the-gap","text":"By providing of typeclasses allowing for expressive description of entity behavior and embedding common event sourcing patterns into these abstractions, we hope to make it more approachable to enjoy side-effect free programming while still benefiting from the great power of Pekko/Akka.","title":"Bridging the gap"},{"location":"/discord.html","text":"","title":"Questions & answers ·"},{"location":"/discord.html#questions-answers","text":"Join the discord channel!","title":"Questions & answers"}]}