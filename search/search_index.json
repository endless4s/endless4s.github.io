{"docs":[{"location":"/paradox.json","text":"","title":""},{"location":"/index.html","text":"endless is a Scala library to describe event sourced entities using tagless-final algebras, running with built-in implementations for Akka.\n/ˈɛndləs/: having or seeming to have no end or limit endless refers to the ever flowing stream of events capturing state evolution with event sourcing, and is a nod to tag-less.","title":""},{"location":"/getting-started.html","text":"","title":"Getting Started ·"},{"location":"/getting-started.html#getting-started","text":"Add the following dependency to your build.sbt file:\nlibraryDependencies += \"io.github.endless4s\" %% \"endless-core\" % \"0.14.4\"\nThis will pull in the core endless module, containing typeclasses and interpreters. You should add this as a dependency to your domain project.\nAkka runtime is available in endless-runtime-akka, and some extra helpers for circe in endless-circe-helpers: add those as dependencies to your infrastructure module.\nYou can also clone this repository and run the example application with sbt run.\nCompatibility Since Akka does not allow mixed versions in a project, Akka dependencies of endless-runtime-akka are marked a Provided. This means that your application libraryDependencies needs to directly include Akka as a dependency. The minimal supported Akka version is 2.6.5.","title":"Getting Started"},{"location":"/nutshell.html","text":"","title":"In a nutshell ·"},{"location":"/nutshell.html#in-a-nutshell","text":"Endless bridges the gap between Cats Effect and Akka Cluster Sharding. It makes it possible to define abstract repository and entity algebras in tagless-final style to describe distributed event sourced domains seamlessly within functional codebases.\nImplementations for various aspects of an entity are provided via abstract interpreters making use of endless typeclasses:\nRepository: represents the ability to interact with a specific entity in the cluster Entity: ability to process a command by reading the state, writing events affecting the state and producing a reply EventApplier: ability to fold events over entity state CommandProtocol: ability to translate entity algebra invocations into serializable commands and replies Effector: ability to produce side effects after event persistence, including passivation of the entity itself\nThe provided Akka runtime is a thin layer over Akka Cluster Sharding and relies exclusively on Akka’s public API. It simply makes use of Akka Persistence entity behavior DSL behind the scenes, while allowing for full customization of the entity behavior if lower-level tweaks are required.\nGenericity Abstractions defined here are universal and could also be operated with a different event-sourcing framework or even a custom implementation. At the moment, built-in support for Akka is provided only.","title":"In a nutshell"},{"location":"/abstractions.html","text":"","title":"Abstractions ·"},{"location":"/abstractions.html#abstractions","text":"All definitions make use of the following type parameters:\nF[_]: abstract effectful context F encapsulating all values, e.g. IO[Boolean] Alg[_[_]]: algebra allowing interaction with the entity, e.g. BookingAlg[IO[*]] ID: entity ID, e.g. BookingID S: entity state, e.g. Booking E: entity event, e.g. BookingEvent","title":"Abstractions"},{"location":"/repository.html","text":"","title":"Repository ·"},{"location":"/repository.html#repository","text":"trait Repository[F[_], ID, Alg[_[_]]] {\n  def entityFor(id: ID): Alg[F]\n}\nRepository is parametrized with entity ID type ID and entity algebra Alg[_[_]]. It represents the ability to obtain an instance of that algebra (the entity) for a specific ID. It is typically used by the interpreter of the repository algebra (e.g. BookingRepository).","title":"Repository"},{"location":"/entity.html","text":"","title":"Entity ·"},{"location":"/entity.html#entity","text":"trait StateReader[F[_], S] {\n  def read: F[S]\n}\ntrait EventWriter[F[_], E] {\n  def write(event: E, other: E*): F[Unit]\n}\ntrait Entity[F[_], S, E] extends StateReader[F, S] with EventWriter[F, E] with Monad[F]\nEntity is parametrized with entity state S and events E. It is a typeclass which represents reader-writer monad capabilities for F with event-sourcing semantics, i.e. the abilities to read current entity state from the context and write events into it. Entity is typically used by the entity algebra command handling interpreter (e.g. BookingEntity).","title":"Entity"},{"location":"/entity.html#functional-event-sourcing","text":"Reader-writer is a natural fit for describing event sourcing behavior: the monadic chain represents event sequencing and corresponding evolution of the state (see also here and here).\nAdvantages of this abstraction are:\nthe command is the call and the reply is simply the final resulting value in the monadic chain, there are no explicit representations maximal composability since it’s just flatMap all the way down, making it easier to work with a reduced set of events read always provides the up-to-date state and event folding happens transparently behind the scenes pure & side-effect free logic that is easy to test\nResponsivity When defining event-sourced entities, it is considered best practice to process commands and formulate a reply quickly as it makes the system responsive. Long-running processes should only initiate as the result of events, which also has the added benefit that they can be restored upon recovery or be driven by a projection. See Effector to find out how to describe side effects with endless.\nAbout performance When composing a sequence of computations which has multiple writes with interspersed reads, the state is folded before each read by the interpreter. This is necessary to provide a constant version of the state during interpretation. This is an operation that the runtime (Akka) will also do behind the scenes when evolving the entity state. Redundant invocations of the folding function can therefore occur with the elevated monadic abstraction. However, in most cases this overhead is insignificant: event application needs to be as fast and simple as possible as it is of course invoked repeatedly for each event during recovery any possible redundant folds only happens upon reception of a command, not upon recovery command handling behavior with multiple interspersed reads and writes is less frequent than the more common read-then-write pattern","title":"Functional event sourcing"},{"location":"/applier.html","text":"","title":"EventApplier ·"},{"location":"/applier.html#eventapplier","text":"trait EventApplier[S, E] extends ((S, E) => String \\/ S) {\n  def apply(state: S, event: E): String \\/ S\n}\nApplication of an event on the entity state (aka. folding the events over the state) is defined with an EventApplier instance, parametrized with the state S and events E. This is a function of the state/event tuple leading to either a new version of the state or an error (\\/ is a type alias for Either).","title":"EventApplier"},{"location":"/protocol.html","text":"","title":"CommandProtocol ·"},{"location":"/protocol.html#commandprotocol","text":"trait CommandProtocol[Alg[_[_]]] {\n  def server[F[_]]: Decoder[IncomingCommand[F, Alg]]\n  def client: Alg[OutgoingCommand[*]]\n}\nCommandProtocol is to be implemented for each entity algebra. It provides a client interpretation wrapping each function into a OutgoingCommand context and a server decoder which can deserialize an incoming command into IncomingCommand.\nOutgoingCommand is able to encode the command into a binary representation ready to be sent over the wire and also decode the expected subsequent reply. IncomingCommand is able to decode the incoming command, invoke the corresponding handler and encode the reply.\nIn other words, client materializes algebra invocations into concrete serializable outgoing commands and server acts as a switchboard for incoming commands. See BookingCommandProtocol for a concrete example.\nExplicit or implicit representations CommandProtocol is the entry point for implementations to map algebra entries to concrete commands and replies. We tend to prefer explicit materialization for migration safety but nothing prevents protocol implementers to opt for automatic serialization via macros. We provide helpers for definition of binary protocols in endless-protobuf-helpers as well as endless-scodec-helpers and JSON protocols in endless-circe-helpers.\nTesting Command protocols can be tested in isolation via synchronous round-trip exercise of the journey client invocation -> command materialization -> command encoding -> command decoding -> behavior invocation -> reply materialization -> reply encoding -> reply decoding. See BookingCommandProtocolSuite for an example.","title":"CommandProtocol"},{"location":"/router.html","text":"","title":"CommandRouter ·"},{"location":"/router.html#commandrouter","text":"trait CommandRouter[F[_], ID] {\n  def routerForID(id: ID): OutgoingCommand[*] ~> F\n}\nCommandRouter represents the ability to deliver a command to its target entity. It provides a natural transformation for an entity ID type, that can map the entity algebra interpreted by CommandProtocol.client into a context OutgoingCommand[*] back to F. This transformation is precisely sending out the command and retrieving the response.\nThere is a built-in implementation for Akka Cluster Sharding: ShardingCommandRouter\nIn order to support natural transformations, a cats-tagless FunctorK instance must be provided for the entity algebra. This is easy to achieve thanks to built-in derivation macros:\nimplicit lazy val functorKInstance: cats.tagless.FunctorK[BookingAlg] = cats.tagless.Derive.functorK[BookingAlg]","title":"CommandRouter"},{"location":"/effector.html","text":"","title":"Effector ·"},{"location":"/effector.html#effector","text":"trait StateReader[F[_], S] {\n  def read: F[Option[S]]\n}\ntrait Passivator[F[_]] {\n  def enablePassivation(after: FiniteDuration = Duration.Zero): F[Unit]\n  def disablePassivation: F[Unit]\n}\ntrait Self[F[_], Alg[_[_]]] {\n  def self: F[Alg[F]]\n}\ntrait Effector[F[_], S] extends StateReader[F, S] with Passivator[F] with Self[F]\nEffector is a typeclass used to describe side effects occurring after event persistence and entity recovery.\nSide-effects are typically asynchronous operations such as kafka writes, outgoing REST requests, and entity passivation (flushing out of memory). Effector is used in a Effector => F[Unit] function provided upon entity deployment (e.g. BookingEffector). In the provided Akka runtime, the resulting F[Unit] is executed in run & forget mode so that command reply is not delayed by any lengthy side-effect (Self can be used to notify success or failure of asynchronous operations back to the entity).\nWarning In the provided Akka runtime, read-only commands (commands that do not generate events) do not trigger side-effects, which corresponds to sound practice.\nNote Defining an effector is entirely optional with the Akka runtime, pass-in (_, _) => EffectorT.unit in deployEntity to disable effector.","title":"Effector"},{"location":"/effector.html#state-derived-side-effects","text":"StateReader allows reading the updated entity state after event persistence or recovery.","title":"State-derived side-effects"},{"location":"/effector.html#passivation","text":"Passivator allow fine grain control over passivation. In certain domains, entities can evolve into “dormant” states (e.g. after a BookingCancelled event) for which it is beneficial to trigger passivation, either immediately or after a certain delay. This enables proactive optimization of cluster resources.","title":"Passivation"},{"location":"/effector.html#self-process-definition","text":"Self exposes the algebra of the entity within the effector context. This allows definition of asynchronous processes that involve interaction with the very same entity, typically to define entities acting as process managers (see below for more detail).\nAt least once delivery with zero latency For most processes, at least once delivery guarantees are required. This can be achieved with a projection, however at the cost of some incurred latency. Actual latency depends on the database and event journal implementation used, as well as the projection throughput. One must also make sure to distribute the projection across the cluster to avoid creating a central choke point. Even so, if a projector process gets stalled for some reason, this can create a cascade effect with events pending processing building up. An effective alternative to using a projection is to track process completion in the entity state itself. Launching asynchronous operations directly as a side-effect of an event has zero latency overhead and also the added advantage that the process launches within the node of the entity which triggered it, thus benefiting from inherent distribution. By enabling remember-entities, we can achieve guaranteed at-least-once completion of asynchronous processes thanks to effector running right after recovery (thus withstanding node crash or shard rebalancing). endless makes it easy to implement this pattern with Self. Here’s the recipe, as illustrated in the example application example: BookingPlaced event gets persisted. At this point, entity state represents pending acceptation of the booking Booking(..., status = Pending) Effector function inspects the state, and in case of Pending status, asks a third-party service for availability and notifies the entity of the result: val availabilityProcess: Booking => F[Unit] = booking =>\n      booking.status match {\n        case Status.Pending =>\n          for {\n            isAvailable <- availabilityAlg.isCapacityAvailable(booking.time, booking.passengerCount)\n            entity <- self\n            _ <- entity.notifyCapacity(isAvailable)\n          } yield ()\n        case _ => ().pure\n      }\n 3.BookingAccepted or BookingRejected events are persisted and entity state is updated accordingly.","title":"Self & process definition"},{"location":"/name.html","text":"","title":"EntityNameProvider ·"},{"location":"/name.html#entitynameprovider","text":"trait EntityNameProvider[ID] extends (() => String)\nEntityNameProvider simply provides the name (type name, or kind) of the entity, for a specific entity ID type. This maps to Akka’s EntityTypeKey.name","title":"EntityNameProvider"},{"location":"/id.html","text":"","title":"EntityIDCodec ·"},{"location":"/id.html#entityidcodec","text":"trait EntityIDEncoder[-ID] {\n  def encode(id: ID): String\n}\ntrait EntityIDDecoder[+ID] {\n  def decode(id: String): ID\n}\ntrait EntityIDCodec[ID] extends EntityIDEncoder[ID] with EntityIDDecoder[ID]\nEntityIDCodec can encode/decode the entity ID into/from String for transmission over the wire together with commands.","title":"EntityIDCodec"},{"location":"/runtime.html","text":"","title":"Akka runtime ·"},{"location":"/runtime.html#akka-runtime","text":"Once required interpreters and typeclass instances have been defined, deploying an entity with Akka boils down to a single call to deployEntity. This naturally requires an actor system and the cluster sharding extension in implicit scope.","title":"Akka runtime"},{"location":"/runtime.html#deployentity","text":"This function brings everything together and delivers a cats effect Resource with the repository instance in context F bundled with the ref to the shard region actor returned by the call to Akka’s ClusterSharding.init.\nThe following snippet is the scaffolding for the library’s sample application, a simple API to manage bookings:\ncopysourcedef apply(implicit actorSystem: ActorSystem[Nothing]): IO[Resource[IO, Server]] = {\n  implicit val clusterSharding: ClusterSharding = ClusterSharding(actorSystem)\n  implicit val commandProtocol: BookingCommandProtocol = new BookingCommandProtocol\n  implicit val eventApplier: BookingEventApplier = new BookingEventApplier\n  implicit val bookingEntityNameProvider: EntityNameProvider[BookingID] = () => \"booking\"\n  implicit val idEncoder: EntityIDCodec[BookingID] =\n    EntityIDCodec(_.id.toString, BookingID.fromString)\n  implicit val askTimeout: Timeout = Timeout(10.seconds)\n\n  Slf4jLogger\n    .create[IO]\n    .map(implicit logger => {\n      deployEntity[IO, Booking, BookingEvent, BookingID, BookingAlg, BookingRepositoryAlg](\n        BookingEntity(_),\n        BookingRepository(_),\n        (effector, _) => BookingEffector(effector)\n      ).map { case (bookingRepository, _) =>\n        httpService(bookingRepository)\n      }\n    })\n    .map(\n      _.flatMap(service =>\n        BlazeServerBuilder[IO]\n          .bindHttp(8080, \"localhost\")\n          .withHttpApp(service)\n          .resource\n      )\n    )\n}\ndeployEntity is parameterized with the context F and the various involved types: S for entity state, E for events, ID for entity ID and Alg & RepositoryAlg for entity and repository algebras respectively (both higher-kinded type constructors).\nEntity algebra Alg must also be equipped with an instance of FunctorK to support natural transformations and CommandRouter.\nIn order to bridge Akka’s implicit asynchronicity with the side-effect free context F used for algebras, it requires Async from F. This makes it possible to use the Dispatcher mechanism for running the command handling monadic chain synchronously from within the actor thread.\nLogger from log4cats is also required as the library supports basic logging capabilities.\nImportant deployEntity needs to be called upon application startup, before joining the cluster as the ClusterSharding extension needs to know about the various entity types beforehand.","title":"deployEntity"},{"location":"/runtime.html#internals","text":"","title":"Internals"},{"location":"/runtime.html#protocol","text":"Thanks to the CommandProtocol instance, entity algebra calls can be “materialized” into concrete commands and replies which are carried in an internal protobuf binary format command.proto. ShardingCommandRouter takes care of delivering the commands to the right entity and returning the reply simply by using Akka’s ask.","title":"Protocol"},{"location":"/runtime.html#deployer","text":"Internally, deployEntity uses Akka EventSourcedBehavior DSL to configure the entity in the following way:","title":"Deployer"},{"location":"/runtime.html#command-handler","text":"use CommandProtocol.server to decode the command and invoke the corresponding algebra logic, interpreted internally with EntityT. Interpretation of the monadic chain occurs, leading to one or more events and a return value. hand in produced events to Akka’s Effect.persist. trigger any side effects in Effector by interpreting it with EffectorT and running it synchronously with Dispatcher from within thenRun encode the reply and feed it into thenReply","title":"Command handler"},{"location":"/runtime.html#event-handler","text":"This is simply a synchronous run of EventApplier (using Dispatcher). Left values are translated into thrown exceptions as Akka doesn’t give us other means to deal with event handling errors.","title":"Event handler"},{"location":"/runtime.html#recovery","text":"Upon successful recovery, we log an info entry and run the effector, while we log a warning entry upon recovery failure.\nCustom behavior The built-in behavior is further customizable via a customizeBehavior function parameter that can be optionally passed into deployEntity.\nCompatibility Since Akka does not allow mixed versions in a project, Akka dependencies of endless-runtime-akka are marked a Provided. This means that your application libraryDependencies needs to directly include Akka as a dependency. The minimal supported Akka version is 2.6.5.","title":"Recovery"},{"location":"/example.html","text":"","title":"Example app ·"},{"location":"/example.html#example-app","text":"Endless example application is a small API for managing imaginary bookings for passenger trips from some origin to some destination. It can be found in endless-example and can be run directly: sbt run.","title":"Example app"},{"location":"/example.html#api","text":"It has a simple CRUD API for those bookings:\ncopysourceprivate def httpService(bookingRepository: BookingRepositoryAlg[IO]): HttpApp[IO] = HttpRoutes\n  .of[IO] {\n    case req @ POST -> Root / \"booking\"                => postBooking(bookingRepository, req)\n    case GET -> Root / \"booking\" / UUIDVar(id)         => getBooking(bookingRepository, id)\n    case req @ PATCH -> Root / \"booking\" / UUIDVar(id) => patchBooking(bookingRepository, req, id)\n    case POST -> Root / \"booking\" / UUIDVar(id) / \"cancel\" => cancelBooking(bookingRepository, id)\n  }\n  .orNotFound","title":"API"},{"location":"/example.html#scaffolding","text":"The application is assembled via a call to deployEntity (see runtime for more details)\ncopysourcedef apply(implicit actorSystem: ActorSystem[Nothing]): IO[Resource[IO, Server]] = {\n  implicit val clusterSharding: ClusterSharding = ClusterSharding(actorSystem)\n  implicit val commandProtocol: BookingCommandProtocol = new BookingCommandProtocol\n  implicit val eventApplier: BookingEventApplier = new BookingEventApplier\n  implicit val bookingEntityNameProvider: EntityNameProvider[BookingID] = () => \"booking\"\n  implicit val idEncoder: EntityIDCodec[BookingID] =\n    EntityIDCodec(_.id.toString, BookingID.fromString)\n  implicit val askTimeout: Timeout = Timeout(10.seconds)\n\n  Slf4jLogger\n    .create[IO]\n    .map(implicit logger => {\n      deployEntity[IO, Booking, BookingEvent, BookingID, BookingAlg, BookingRepositoryAlg](\n        BookingEntity(_),\n        BookingRepository(_),\n        (effector, _) => BookingEffector(effector)\n      ).map { case (bookingRepository, _) =>\n        httpService(bookingRepository)\n      }\n    })\n    .map(\n      _.flatMap(service =>\n        BlazeServerBuilder[IO]\n          .bindHttp(8080, \"localhost\")\n          .withHttpApp(service)\n          .resource\n      )\n    )\n}","title":"Scaffolding"},{"location":"/example.html#algebras","text":"You might have spotted the two algebra types in the snippet above, which are defined like so:\ncopysourcetrait BookingRepositoryAlg[F[_]] {\n  def bookingFor(bookingID: BookingID): BookingAlg[F]\n}\ncopysourcetrait BookingAlg[F[_]] {\n  def place(\n      bookingID: BookingID,\n      time: Instant,\n      passengerCount: Int,\n      origin: LatLon,\n      destination: LatLon\n  ): F[BookingAlreadyExists \\/ Unit]\n  def get: F[BookingUnknown.type \\/ Booking]\n  def changeOrigin(newOrigin: LatLon): F[BookingUnknown.type \\/ Unit]\n  def changeDestination(newDestination: LatLon): F[BookingUnknown.type \\/ Unit]\n  def changeOriginAndDestination(\n      newOrigin: LatLon,\n      newDestination: LatLon\n  ): F[BookingUnknown.type \\/ Unit]\n  def cancel: F[CancelError \\/ Unit]\n  def notifyCapacity(isAvailable: Boolean): F[BookingUnknown.type \\/ Unit]\n}","title":"Algebras"},{"location":"/example.html#implementations","text":"Implementation of the repository algebra is trivial using Repository instance (injected by deployEntity):\ncopysourcefinal case class BookingRepository[F[_]: Monad](repository: Repository[F, BookingID, BookingAlg])\n    extends BookingRepositoryAlg[F] {\n  import repository._\n  def bookingFor(bookingID: BookingID): BookingAlg[F] = entityFor(bookingID)\n}\nImplementation of entity algebra is done using the Entity typeclass instance (also injected by deployEntity):\ncopysourcefinal case class BookingEntity[F[_]: Monad: Logger](entity: Entity[F, Booking, BookingEvent])\n    extends BookingAlg[F] {\n  import entity._\n\n  def place(\n      bookingID: BookingID,\n      time: Instant,\n      passengerCount: Int,\n      origin: LatLon,\n      destination: LatLon\n  ): F[BookingAlreadyExists \\/ Unit] =\n    ifUnknownF(\n      Logger[F].info(show\"Creating booking with ID $bookingID\") >> write(\n        BookingPlaced(bookingID, time, origin, destination, passengerCount)\n      )\n    )(_ => BookingAlreadyExists(bookingID))\n\n  def get: F[BookingUnknown.type \\/ Booking] = ifKnown(identity)(BookingUnknown)\n\n  def changeOrigin(newOrigin: LatLon): F[BookingUnknown.type \\/ Unit] =\n    ifKnownF(booking =>\n      if (booking.origin =!= newOrigin) entity.write(OriginChanged(newOrigin)) else ().pure\n    )(BookingUnknown)\n\n  def changeDestination(newDestination: LatLon): F[BookingUnknown.type \\/ Unit] =\n    ifKnownF(booking =>\n      if (booking.destination =!= newDestination) entity.write(DestinationChanged(newDestination))\n      else ().pure\n    )(BookingUnknown)\n\n  def changeOriginAndDestination(\n      newOrigin: LatLon,\n      newDestination: LatLon\n  ): F[BookingUnknown.type \\/ Unit] = changeOrigin(newOrigin) >> changeDestination(newDestination)\n\n  def cancel: F[CancelError \\/ Unit] =\n    ifKnownT[CancelError, Unit](booking =>\n      booking.status match {\n        case Status.Accepted  => EitherT.liftF(entity.write(BookingCancelled))\n        case Status.Pending   => EitherT.liftF(entity.write(BookingCancelled))\n        case Status.Cancelled => EitherT.pure(())\n        case Status.Rejected  => EitherT.leftT[F, Unit](BookingAlg.BookingWasRejected(booking.id))\n      }\n    )(\n      BookingUnknown\n    )\n\n  def notifyCapacity(isAvailable: Boolean): F[BookingAlg.BookingUnknown.type \\/ Unit] =\n    ifKnownF(_.status match {\n      case Status.Pending =>\n        if (isAvailable) entity.write(BookingAccepted) else entity.write(BookingRejected)\n      case _ => ().pure\n    })(\n      BookingUnknown\n    )\n}","title":"Implementations"},{"location":"/example.html#event-handling","text":"In this simple example, events essentially set fields in the state:\ncopysourceclass BookingEventApplier extends EventApplier[Booking, BookingEvent] {\n  def apply(state: Option[Booking], event: BookingEvent): String \\/ Option[Booking] =\n    (event match {\n      case BookingPlaced(bookingID, time, origin, destination, passengerCount) =>\n        state\n          .toLeft(Booking(bookingID, time, origin, destination, passengerCount))\n          .leftMap(_ => \"Booking already exists\")\n      case OriginChanged(newOrigin) =>\n        state\n          .toRight(\"Attempt to change unknown booking\")\n          .map(_.copy(origin = newOrigin))\n      case DestinationChanged(newDestination) =>\n        state\n          .toRight(\"Attempt to change unknown booking\")\n          .map(_.copy(destination = newDestination))\n      case BookingAccepted =>\n        state\n          .toRight(\"Attempt to accept unknown booking\")\n          .map(_.copy(status = Booking.Status.Accepted))\n      case BookingRejected =>\n        state\n          .toRight(\"Attempt to reject unknown booking\")\n          .map(_.copy(status = Booking.Status.Rejected))\n      case BookingCancelled =>\n        state\n          .toRight(\"Attempt to cancel unknown booking\")\n          .map(_.copy(status = Booking.Status.Cancelled))\n    }).map(Option(_))\n}","title":"Event handling"},{"location":"/example.html#protocol","text":"Command and reply encoding/decoding on client and server side is done by interpreting the entity algebra with IncomingCommand and OutgoingCommand contexts respectively:\ncopysourceclass BookingCommandProtocol extends CirceCommandProtocol[BookingAlg] {\n  override def client: BookingAlg[OutgoingCommand[*]] =\n    new BookingAlg[OutgoingCommand[*]] {\n      def place(\n          bookingID: BookingID,\n          time: Instant,\n          passengerCount: Int,\n          origin: LatLon,\n          destination: LatLon\n      ): OutgoingCommand[BookingAlreadyExists \\/ Unit] =\n        outgoingCommand[BookingCommand, BookingAlreadyExists \\/ Unit](\n          PlaceBooking(bookingID, time, passengerCount, origin, destination)\n        )\n\n      // ...\ncopysourceoverride def server[F[_]]: Decoder[IncomingCommand[F, BookingAlg]] =\n  CirceDecoder(io.circe.Decoder[BookingCommand].map {\n    case PlaceBooking(\n          bookingID: BookingID,\n          time: Instant,\n          passengerCount: Int,\n          origin: LatLon,\n          destination: LatLon\n        ) =>\n      incomingCommand[F, BookingAlreadyExists \\/ Unit](\n        _.place(bookingID, time, passengerCount, origin, destination)\n      )","title":"Protocol"},{"location":"/example.html#side-effects","text":"We describe availability process as well as explicit entity passivation using Effector:\ncopysourceobject BookingEffector {\n  def apply[F[_]: Logger: Monad](\n      effector: Effector[F, Booking, BookingAlg]\n  )(implicit availabilityAlg: AvailabilityAlg[F]): F[Unit] = {\n    import effector._\n\n    val availabilityProcess: Booking => F[Unit] = booking =>\n      booking.status match {\n        case Status.Pending =>\n          for {\n            isAvailable <- availabilityAlg.isCapacityAvailable(booking.time, booking.passengerCount)\n            entity <- self\n            _ <- entity.notifyCapacity(isAvailable)\n          } yield ()\n        case _ => ().pure\n      }\n\n    val handlePassivation: Booking => F[Unit] = {\n      _.status match {\n        case Status.Pending   => Applicative[F].unit\n        case Status.Accepted  => enablePassivation(passivationDelay)\n        case Status.Rejected  => enablePassivation()\n        case Status.Cancelled => enablePassivation()\n      }\n    }\n\n    ifKnown(booking => Logger[F].info(show\"State is now $booking\")) >> ifKnown(\n      availabilityProcess\n    ) >> ifKnown(handlePassivation)\n  }\n\n  private val passivationDelay = 1.hour\n}","title":"Side-effects"},{"location":"/example.html#testing","text":"Unit testing for entity algebra implementation, event handling and effector is easy thanks to the parametric nature of F:\ncopysourceclass BookingEntitySuite\n    extends munit.CatsEffectSuite\n    with munit.ScalaCheckEffectSuite\n    with Generators {\n  implicit private val logger: TestingLogger[IO] = TestingLogger.impl[IO]()\n  private val bookingAlg = BookingEntity(EntityT.instance[IO, Booking, BookingEvent])\n  private implicit val eventApplier: BookingEventApplier = new BookingEventApplier\n\n  test(\"place booking\") {\n    forAllF { booking: Booking =>\n      bookingAlg\n        .place(\n          booking.id,\n          booking.time,\n          booking.passengerCount,\n          booking.origin,\n          booking.destination\n        )\n        .run(None)\n        .map {\n          case Right((events, _)) =>\n            assertEquals(\n              events,\n              Chain(\n                BookingPlaced(\n                  booking.id,\n                  booking.time,\n                  booking.origin,\n                  booking.destination,\n                  booking.passengerCount\n                )\n              )\n            )\n          case Left(error) => fail(error)\n        }\n        .flatMap(_ => assertIOBoolean(logger.logged.map(_.nonEmpty)))\n    }\n  }\n\n  test(\"change origin and destination\") {\n    forAllF { (booking: Booking, newOrigin: LatLon, newDestination: LatLon) =>\n      bookingAlg\n        .changeOriginAndDestination(newOrigin, newDestination)\n        .run(Some(booking))\n        .map {\n          case Right((events, _)) =>\n            assertEquals(\n              events,\n              Chain[BookingEvent](OriginChanged(newOrigin), DestinationChanged(newDestination))\n            )\n          case _ => fail(\"unexpected\")\n        }\n    }\n  }\ncopysourceclass BookingEventApplierSuite extends munit.ScalaCheckSuite with Generators {\n  property(\"booking placed when unknown\") {\n    forAll { booking: Booking =>\n      val fold = new BookingEventApplier()(\n        None,\n        BookingPlaced(\n          booking.id,\n          booking.time,\n          booking.origin,\n          booking.destination,\n          booking.passengerCount\n        )\n      )\n      assertEquals(fold, Right(Some(booking)))\n    }\n  }\n\n  property(\"booking placed when known\") {\n    forAll { booking: Booking =>\n      val fold = new BookingEventApplier()(\n        Some(booking),\n        BookingPlaced(\n          booking.id,\n          booking.time,\n          booking.origin,\n          booking.destination,\n          booking.passengerCount\n        )\n      )\n      assert(fold.isLeft)\n    }\n  }\n\n  property(\"origin changed when known\") {\n    forAll { (booking: Booking, newOrigin: LatLon) =>\n      val fold = new BookingEventApplier()(Some(booking), OriginChanged(newOrigin))\n      assertEquals(fold.toOption.flatMap(_.map(_.origin)), Option(newOrigin))\n    }\n  }\n\n  property(\"origin changed when unknown\") {\n    forAll { newOrigin: LatLon =>\n      val fold = new BookingEventApplier()(None, OriginChanged(newOrigin))\n      assert(fold.isLeft)\n    }\n  }\n\n  property(\"destination changed when known\") {\n    forAll { (booking: Booking, newDestination: LatLon) =>\n      val fold = new BookingEventApplier()(Some(booking), DestinationChanged(newDestination))\n      assertEquals(fold.toOption.flatMap(_.map(_.destination)), Option(newDestination))\n    }\n  }\n\n  property(\"destination changed when unknown\") {\n    forAll { newDestination: LatLon =>\n      val fold = new BookingEventApplier()(None, DestinationChanged(newDestination))\n      assert(fold.isLeft)\n    }\n  }\n\n  property(\"booking accepted when known\") {\n    forAll { booking: Booking =>\n      val fold = new BookingEventApplier()(Some(booking), BookingAccepted)\n      assertEquals(fold.toOption.flatMap(_.map(_.status)), Option(Booking.Status.Accepted))\n    }\n  }\n\n  property(\"booking accepted when unknown\") {\n    val fold = new BookingEventApplier()(None, BookingAccepted)\n    assert(fold.isLeft)\n\n  }\n\n  property(\"booking rejected when known\") {\n    forAll { booking: Booking =>\n      val fold = new BookingEventApplier()(Some(booking), BookingRejected)\n      assertEquals(fold.toOption.flatMap(_.map(_.status)), Option(Booking.Status.Rejected))\n    }\n  }\n\n  property(\"booking rejected when unknown\") {\n    val fold = new BookingEventApplier()(None, BookingRejected)\n    assert(fold.isLeft)\n  }\n\n  property(\"booking cancelled when known\") {\n    forAll { booking: Booking =>\n      val fold = new BookingEventApplier()(Some(booking), BookingCancelled)\n      assertEquals(fold.toOption.flatMap(_.map(_.status)), Option(Booking.Status.Cancelled))\n    }\n  }\n\n  property(\"booking cancelled when unknown\") {\n    val fold = new BookingEventApplier()(None, BookingCancelled)\n    assert(fold.isLeft)\n  }\n}\ncopysourceclass BookingEffectorSuite\n    extends munit.CatsEffectSuite\n    with munit.ScalaCheckEffectSuite\n    with Generators {\n  implicit private val logger: TestingLogger[IO] = TestingLogger.impl[IO]()\n  implicit private def availabilityAlg[F[_]: Applicative]: AvailabilityAlg[F] =\n    (_: Instant, _: Int) => Applicative[F].pure(true)\n  private val effector = BookingEffector(EffectorT.instance[IO, Booking, BookingAlg])\n\n  test(\"some state log\") {\n    forAllF { booking: Booking =>\n      val acceptedBooking = booking.copy(status = Booking.Status.Accepted)\n      effector\n        .runA(Some(acceptedBooking), new SelfEntity {})\n        .flatMap(_ =>\n          assertIO(logger.logged.map(_.map(_.message).last), show\"State is now $acceptedBooking\")\n        )\n    }\n  }\n\n  test(\"some state passivate after one hour\") {\n    forAllF { booking: Booking =>\n      assertIO(\n        effector.runS(Some(booking.copy(status = Booking.Status.Accepted)), new SelfEntity {}),\n        PassivationState.After(1.hour)\n      )\n    }\n  }\n\n  test(\"passivate immediately when cancelled\") {\n    forAllF { booking: Booking =>\n      assertIO(\n        effector.runS(Some(booking.copy(status = Booking.Status.Cancelled)), new SelfEntity {}),\n        PassivationState.After(Duration.Zero)\n      )\n    }\n  }\n\n  test(\"notifies availability when pending and does not passivate\") {\n    forAllF { booking: Booking =>\n      assertIO(\n        effector.runS(\n          Some(booking.copy(status = Booking.Status.Pending)),\n          new SelfEntity {\n            override def notifyCapacity(\n                isAvailable: Boolean\n            ): IO[BookingAlg.BookingUnknown.type \\/ Unit] = {\n              assert(isAvailable)\n              IO.pure(().asRight)\n            }\n          }\n        ),\n        PassivationState.Disabled\n      )\n    }\n  }\n\n  trait SelfEntity extends BookingAlg[IO] {\n    override def place(\n        bookingID: Booking.BookingID,\n        time: Instant,\n        passengerCount: Int,\n        origin: Booking.LatLon,\n        destination: Booking.LatLon\n    ): IO[BookingAlg.BookingAlreadyExists \\/ Unit] =\n      IO.raiseError(new RuntimeException(\"should not be called\"))\n\n    override def get: IO[BookingAlg.BookingUnknown.type \\/ Booking] =\n      IO.raiseError(new RuntimeException(\"should not be called\"))\n\n    override def changeOrigin(\n        newOrigin: Booking.LatLon\n    ): IO[BookingAlg.BookingUnknown.type \\/ Unit] =\n      IO.raiseError(new RuntimeException(\"should not be called\"))\n\n    override def changeDestination(\n        newDestination: Booking.LatLon\n    ): IO[BookingAlg.BookingUnknown.type \\/ Unit] =\n      IO.raiseError(new RuntimeException(\"should not be called\"))\n\n    override def changeOriginAndDestination(\n        newOrigin: Booking.LatLon,\n        newDestination: Booking.LatLon\n    ): IO[BookingAlg.BookingUnknown.type \\/ Unit] =\n      IO.raiseError(new RuntimeException(\"should not be called\"))\n\n    override def cancel: IO[BookingAlg.CancelError \\/ Unit] =\n      IO.raiseError(new RuntimeException(\"should not be called\"))\n\n    override def notifyCapacity(isAvailable: Boolean): IO[BookingAlg.BookingUnknown.type \\/ Unit] =\n      IO.raiseError(new RuntimeException(\"should not be called\"))\n  }\n\n}\nCommand protocol can be also easily be covered with synchronous round-trip tests:\ncopysourceclass BookingCommandProtocolSuite extends munit.ScalaCheckSuite with Generators {\n  val protocol = new BookingCommandProtocol\n\n  test(\"place booking\") {\n    forAll { (booking: Booking, reply: BookingAlg.BookingAlreadyExists \\/ Unit) =>\n      val outgoingCommand = protocol.client.place(\n        booking.id,\n        booking.time,\n        booking.passengerCount,\n        booking.origin,\n        booking.destination\n      )\n      val incomingCommand = protocol.server[Id].decode(outgoingCommand.payload)\n      val encodedReply = incomingCommand\n        .runWith(new TestBookingAlg {\n          override def place(\n              bookingID: Booking.BookingID,\n              time: Instant,\n              passengerCount: Int,\n              origin: Booking.LatLon,\n              destination: Booking.LatLon\n          ): Id[BookingAlg.BookingAlreadyExists \\/ Unit] = reply\n        })\n        .map(incomingCommand.replyEncoder.encode(_))\n      assertEquals(outgoingCommand.replyDecoder.decode(encodedReply), reply)\n    }\n  }\nComponent and integration tests using akka testkit are also advisable and work as usual, see ExampleAppSuite.","title":"Testing"},{"location":"/reference.html","text":"","title":"Reference ·"},{"location":"/reference.html#reference","text":"Core API documentation Runtime API documentation Endless circe helpers API documentation","title":"Reference"},{"location":"/inspiration.html","text":"","title":"Inspiration ·"},{"location":"/inspiration.html#inspiration","text":"Our journey towards elevation of our event-sourcing code abstraction level started with an inheritance-based model, that we described in this article. We introduced EntityCommand and EntityEvent traits, which allowed us in turn to define someCommandProcessor and EventApplier constructs with generic implementations and mappings for Akka. This was already a good step in the right direction as it allowed us to host command handling and event handling logic in the domain, free from any Akka dependencies.","title":"Inspiration"},{"location":"/inspiration.html#implicit-commands-replies","text":"However, with this approach, commands and replies are still an integral part of the domain model. And if you think about it, such models and associated mappings to/from values do not add any value to domain expression, rather the contrary. Domain code is more compact if we can use straight algebras and values, without concern for the underlying necessary reification to cross node boundaries in the cluster. It was also always an open question for us how to best integrate event sourcing within functional codebases. Since event-sourcing looks a lot like a reader-writer monad, we felt there was some potential there.","title":"Implicit commands & replies"},{"location":"/inspiration.html#aecor","text":"At this point, we ran into the outstanding work done by Denis Mikhaylov & contributors on Aecor as well as the excellent blog series by Vladimir Pavkin. This was a real eye-opener, and we highly recommend the read!\nHowever, we could not use the library directly for a number of reasons, chiefly because we are attached to keeping the layer above Akka as lightweight as possible and we want to keep control on serialization aspects. There also are other more subtle differences: for instance we consider command rejections (and more generally, “business errors”) as first-order values, therefore opting for Either for replies. In endless, we’ve also tried to stick to close to DDD & Akka nomenclature as much as possible.","title":"Aecor"},{"location":"/inspiration.html#bridging-the-gap","text":"By providing of typeclasses allowing for expressive description of entity behavior and embedding common event sourcing patterns into these abstractions, we hope to make it more approachable to enjoy side-effect free programming while still benefiting from the great power of Akka.","title":"Bridging the gap"},{"location":"/discord.html","text":"","title":"Questions & answers ·"},{"location":"/discord.html#questions-answers","text":"Join the discord channel!","title":"Questions & answers"}]}